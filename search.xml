<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vim文件头配置]]></title>
    <url>%2F2019%2F02%2F21%2Fvim%E6%96%87%E4%BB%B6%E5%A4%B4%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[很多时候希望写代码的时候Vim能自动添加文件头，显示一些注释比如作者、创建时间、修改时间等等信息。事前先百度，参考了一些教程之后实际动手操作了一番，记录下我在用的代码。 修改 /etc/vimrc 文件，在末尾添加一下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243" 使用&lt;F4&gt;作为触发条件map &lt;F4&gt; :call TitleDet()&lt;cr&gt;'s“ 添加文件头function AddTitle() call append(0,"/* ") call append(1," * Author : Haoojie") call append(2," * Create time : ".strftime("%Y-%m-%d %H:%M")) call append(3," * Last modified : ".strftime("%Y-%m-%d %H:%M")) call append(4," * Filename : ".expand("%:t")) call append(5," * Description : ") call append(6," */") call append(7,"") echohl WarningMsg | echo "Successful in adding the copyright." | echohl Noneendf“ 更新文件时间和描述function UpdateTitle() normal m' execute '/ * Last modified :/s@:.*$@\=strftime(": %Y-%m-%d %H:%M")@' normal '' normal mk execute '/ * Filename :/s@:.*$@\=": ".expand("%:t")@' execute "noh" normal 'k echohl WarningMsg | echo "Successful in updating the copy right." | echohl Noneendfunction“ 主函数“ 如果前8行有 Last modified，更新文件头“ 如果前8行没有 Last modified，添加文件头function TitleDet() let n=1 while n &lt; 8 let line = getline(n) if line =~ '^\s\*\sLast\smodified\s:\s*.*$' call UpdateTitle() return endif let n = n + 1 endwhile call AddTitle()endfunction 参考链接VIM 一键自动添加文件头注释]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openwrt踩坑]]></title>
    <url>%2F2018%2F12%2F05%2Fopenwrt%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[前言由于业务上的需求，本来在做Android开发的我直接被从零开始，搞了几个月的OpenWrt。哇，本来还有点小激动，结果没人带，每天都是在 查资料 - 改代码 - 刷固件 - 查资料 循环。还好最后不负众望，现在总结一下被OpenWrt折磨的几个月的东西。 一、环境篇 依赖环境 1sudo apt-get install build-essential subversion libncurses5-dev zlib1g-dev gawk gcc-multilib flex git-core gettext libssl-dev ccache 下载安装更新 123456# 下载最新的源代码# 可以使用 gitlib 上的版本git clone https://github.com/openwrt/openwrt./scripts/feeds update -a./scripts/feeds install -a 交叉编译环境搭建 在 OpenWrt 官网下载SDK，如 mt7621 SDK 链接地址 将SDK解压到某个位置，如 /usr/local/openwrt_sdk 设置交叉编译器的环境变量 1234vim ~/.bashrcexport PATH='/usr/local/openwrt_sdk/OpenWrt-SDK-15.05.1-ramips-mt7621_gcc-4.8-linaro_uClibc-0.9.33.2.Linux-x86_64/staging_dir/toolchain-mipsel_1004kc+dsp_gcc-4.8-linaro_uClibc-0.9.33.2/bin':$&#123;PATH&#125;export STAGING_DIR='/usr/local/openwrt_sdk/OpenWrt-SDK-15.05.1-ramips-mt7621_gcc-4.8-linaro_uClibc-0.9.33.2.Linux-x86_64/staging_dir' 如果安装成功，输入 mips 后按 Tab 键会出现 mipsel-openwrt-linux- 交叉编译 1mipsel-openwrt-linux-gcc helloworld.c -o helloworld 二、网络篇 默认添加iptables规则 12vim package/network/config/firewall/files/firewall.user+ iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o tun0 -j MASQUERADE 允许包转发 123456vim package/network/config/firewall/files/firewall.configconfig defaults option syn_flood 1 option input ACCEPT option output ACCEPT-/+ option forward ACCEPT # 允许转发 WiFi默认开启、SSID修改 12345vim package/kernel/mac80211/files/lib/wifi/mac80211.sh-/+ set wireless.radio$&#123;devidx&#125;.disabled=0 # 0-默认开启 1-默认关闭-/+ set wireless.default_radio$&#123;devidx&#125;.ssid=AP-TEST # SSID# SSID 可以实现名称后缀（以MAC地址做后缀） # set wireless.default_radio$&#123;devidx&#125;.ssid=TS-$(cat /sys/class/net/eth0/address |sed 's/://g') 修改默认LAN IP 1234567vim package/base-files/files/bin/config_generatecase "protocol" in static) local ipad case "$1" in-/+ lan) ipad=$&#123;ipaddr:-"192.168.1.1"&#125; ;; # 改这里 *) ipad=$&#123;ipaddr:-"192.168.$((addr_offset++)).1"&#125; ;; 添加/修改网络接口 12345678910111213141516vim package/base-files/files/bin/config_generate// 默认为电信4Ggenerate_static_network() &#123;+ uci -q batch &lt;&lt;-EOF+ set network.ppp0='interface'+ set network.ppp0.ifname='34G'+ set network.ppp0.proto='3g'+ set network.ppp0.apn='CTNET'+ set network.ppp0.service='umts'+ set network.ppp0.dialnumber='*99#'+ set network.ppp0.username='ctnet@mycdma.cn'+ set network.ppp0.password='vnet.mobi'+ set network.ppp0.device='/dev/ttyUSB1'+ set network.ppp0.dns='114.114.114.114'+ EOF 查看网口的 port 123# 安装 swconfig 工具swconfig list # 查看 switch 设备swconfig dev eth0 show # 查看网口及其状态，通过插拔网线可以看到端口状态的变化 修改 switch 12345678910# 确认网口后，修改网口 lan/wan 状态vim target/linux/ar71xx/base-files/etc/board.d/02_network ap143|\ rb-433|\ rb-433u) ucidef_set_interfaces_lan_wan "eth0" "eth1" ucidef_add_switch "switch0" \ "2:lan" "3:lan" "4:lan" "0@eth1" ;; 三、系统篇 开机自启 123vim package/base-files/files/etc/rc.local+ /etc/init.d/cron enable+ /etc/init.d/cron start 查看分区 12345678910cat /proc/mtddev: size erasesize namemtd0: 00080000 00010000 "u-boot"mtd1: 00170000 00010000 "kernel"mtd2: 00e00000 00010000 "rootfs"mtd3: 00900000 00010000 "rootfs_data"mtd4: 00010000 00010000 "art"mtd5: 00f70000 00010000 "firmware"mtd6: 01000000 00010000 "all" 查看分区 1cat /proc/cmdline 修改分区 1234vim target/linux/ar71xx/image/legacy.mk-/+ ap147_mtdlayout=mtdparts=... // 改成想要的分区，如果修改了顺序，需要修改下一处的最后一个单词 RKuImage, 按修改后的顺序填写-/+ $(eval $(call SingleProfile,AthLzma,64k,AP147_010,ap147-010,AP147-010,ttyS0,115200,$$(ap147_mtdlayout),KRuImage)) 喂狗 123456789101112131415161718192021222324252627282930313233343536373839vim build_dir/target-mips_24kc_musl/linux-ar71xx_generic/linux-4.9.111/arch/mips/ath79/mach-ap147.c#include &lt;linux/gpio.h&gt;#define AP147_GPIO_XWDT 17 // watchdog gpio#define XWDT_AUTOFEED_DURATION (HZ / 3) // 喂狗时间static int gpio_external_wdt = -1;static int wdt_timeout = -1, wdt_autofeed_count = 0;static void watchdog_fire(unsigned long);static struct timer_list watchdog_ticktock = TIMER_INITIALIZER(watchdog_fire, 0, 0);static void external_wdt_toggle(void) &#123; static u32 data; data ++; gpio_set_value(gpio_external_wdt, data &amp; 0x01);&#125;static void watchdog_fire(unsigned long data) &#123; if(wdt_timeout &gt; 0) wdt_autofeed_count++; if((wdt_timeout &lt; 0) || (wdt_autofeed_count &lt; wdt_timeout)) &#123; external_wdt_toggle(); mod_timer(&amp;watchdog_ticktock, jiffies + XWDT_AUTOFEED_DURATION); &#125;&#125;static void enable_external_wdt(int gpio) &#123; printk("register watchdog init\n"); gpio_external_wdt = gpio; wdt_timeout = -1; mod_timer(&amp;watchdog_ticktock, jiffies + XWDT_AUTOFEED_DURATION);&#125;void __init ap147_setup(vodi) &#123; ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE); ath79_gpio_output_select(AP147_GPIO_XWDT, 0); enable_external_wdt(AP147_GPIO_XWDT);&#125; 查看系统 GPIO 1234567cat /sys/kernel/debug/gpioGPIOs 0-17, platform/ath79-gpio, ath79: gpio-1 ( |ap143:green:sys ) out lo gpio-3 ( |WPS button ) in hi gpio-12 ( |wlan_2g ) out lo gpio-13 ( |ap143:green:status ) out hi RESET 按钮的设置 注册 RESET 的 GPIO 12345678910111213141516171819vim build_dir/target-mips_24kc_musl/linux-ar71xx_generic/linux-4.9.111/arch/mips/ath79/mach-ap143.c// 添加 RESET GPIO#define AP143_GPIO_BTN_RESET 3// 注册 RESET BUTTONstatic struct gpio_keys_button ap143_gpio_keys[] __initdata = &#123; &#123; ... &#125;, &#123; .desc = "RESET button", .type = EV_KEY, .code = KEY_RESTART, .debounce_interval = AP143_KEYS_DEBOUNCE_INTERVAL, .gpio = AP143_GPIO_BTN_RESET, .active_low = 1, &#125;&#125;; 添加 reset 脚本（按下去时间 &gt; 5 reset） 1234567891011121314151617181920212223242526272829vim ./package/base-files/files/etc/rc.button/reset#!/bin/sh. /lib/functions.shcase "$ACTION" inpressed) return 5;;timeout) . /etc/diag.sh set_state failsafe;;released) if [ "$SEEN" -lt 1 ] then echo "REBOOT" &gt; /dev/console sync reboot elif [ "$SEEN" -gt 5 ] then echo "FACTORY RESET" &gt; /dev/console jffs2reset -y &amp;&amp; reboot &amp; fi;;esacreturn 0 修改LUCI界面初始化的小字 及 首页URL 1234567891011121314151617vim feeds/luci/modules/luci-base/root/www/index.html orvim package/feeds/luci/luci-base/root/www/index.htmlpackage/feeds/luci/luci-base&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Cache-Control" content="no-cache" /&gt;-/+ &lt;meta http-equiv="refresh" content="0; URL=/cgi-bin/luci/login" /&gt; &lt;!-- 你想要的首页的URL --&gt; &lt;/head&gt; &lt;body style="background-color: white"&gt; &lt;!-- 你想要的首页的URL --&gt; &lt;!-- 你想要的提示 --&gt;-/+ &lt;a style="color: black; font-family: arial, helvetica, sans-serif;" href="/cgi-bin/luci/login"&gt;欢迎登录xxx&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; LED灯配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061vim build_dir/target-mips_24kc_musl/linux-ar71xx_generic/linux-4.9.111/arch/mips/ath79/mach-ap143.c// LED GPIO 定义#define AP143_GPIO_LED_WLAN 12#define AP143_GPIO_LED_SYS 1#define AP143_GPIO_LED_WPS 13#define AP143_GPIO_LED_STATUS 13#define AP143_GPIO_LED_WAN 11#define AP143_GPIO_LED_LAN1 4#define AP143_GPIO_LED_LAN2 16#define AP143_GPIO_LED_LAN3 15#define AP143_GPIO_LED_LAN4 14// LED GPIO 注册static struct gpio_led ap143_leds_gpio[] __initdata = &#123; &#123; .name = "ap143:green:status", .gpio = AP143_GPIO_LED_STATUS, .active_low = 1, &#125;, &#123; .name = "ap143:green:wlan", .gpio = AP143_GPIO_LED_WLAN, .active_low = 1, &#125;, &#123; .name = "ap143:green:sys", .gpio = AP143_GPIO_LED_SYS, .active_low = 0, &#125;&#125;;// LED 闪烁// 未配置的灯会常亮或者常灭static void __init ap143_gpio_led_setup(void)&#123; ath79_gpio_direction_select(AP143_GPIO_LED_WAN, true); ath79_gpio_direction_select(AP143_GPIO_LED_LAN1, true); ath79_gpio_direction_select(AP143_GPIO_LED_LAN2, true); ath79_gpio_direction_select(AP143_GPIO_LED_LAN3, true); ath79_gpio_direction_select(AP143_GPIO_LED_LAN4, true); ath79_gpio_output_select(AP143_GPIO_LED_WAN, QCA953X_GPIO_OUT_MUX_LED_LINK5); ath79_gpio_output_select(AP143_GPIO_LED_LAN1, QCA953X_GPIO_OUT_MUX_LED_LINK1); ath79_gpio_output_select(AP143_GPIO_LED_LAN2, QCA953X_GPIO_OUT_MUX_LED_LINK2); ath79_gpio_output_select(AP143_GPIO_LED_LAN3, QCA953X_GPIO_OUT_MUX_LED_LINK3); ath79_gpio_output_select(AP143_GPIO_LED_LAN4, QCA953X_GPIO_OUT_MUX_LED_LINK4); ath79_register_leds_gpio(-1, ARRAY_SIZE(ap143_leds_gpio), ap143_leds_gpio); ath79_register_gpio_keys_polled(-1, AP143_KEYS_POLL_INTERVAL, ARRAY_SIZE(ap143_gpio_keys), ap143_gpio_keys); ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);&#125; 添加用户 1234# 按照相同格式在一下文件中添加记录vim package/base-files/files/etc/passwdvim package/base-files/files/etc/shadowvim package/base-files/files/etc/group 四、软件篇 添加自己的程序 - HelloWorld（含依赖库的helloworld程序） 创建hellloworld包 123456789cd packagemkdir helloworld// 目录如下helloworld/├── Makefile // Helloworld.ipk 的整体 Makefile;└── src // 源程序 ├── main.c // 源文件 └── Makefile // 源 MakeFile 源文件 1234567891011vim helloworld/src/main.c #include &lt;stdio.h&gt; int main(void) &#123;if (sodium_init() == -1) return -1; // 依赖库，测试是否包含libsodiumprintf("\n********************************\n");printf(" hello world! \n");printf("********************************\n\n");return 0;&#125; 源Makefile 1234567891011121314151617vim helloworld/src/Makefile OBJECTS=helloworldLIBS += -lsodium all:$(OBJECTS)PKG_NAME=docs helloworld:main.o$(CC) $(LDFLAGS) $(LIBS) -std=c99 $^ -o $@ main.o:main.c$(CC) $(CFLAGS) -std=c99 -c $&lt; .PHONY:cleanclean:@-rm *.o helloworld 整体Makefile 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768vim helloworld/Makefile ### Copyright (C) 2014 OpenWrt.org### This is free software, licensed under the GNU General Public License v2.# See /LICENSE for more information.# include $(TOPDIR)/rules.mk # 必须 PKG_NAME:=helloworld # 包名PKG_VERSION:=1.0 # 版本号PKG_RELEASE:=1 # 构建号 include $(INCLUDE_DIR)/package.mk # 必须 PKG_BUILD_DIR:=$(BUILD_DIR)/$(PKG_NAME)-$(PKG_VERSION) # 构建包的路径 # 包的简介以及 menuconfig 的位置define Package/$(PKG_NAME)SECTION:=utilsCATEGORY:=UtilitiesTITLE:=helloworld -- a Test ProgramDEPENDS:=+libsodium # 依赖库endef # 包的描述，可以为空define Package/$(PKG_NAME)/descriptiona test program, Hello World!endef # 构建包之前的准备，可以为空，会自动创建define Build/Preparemkdir -p $(PKG_BUILD_DIR) # 创建 构建包的路径cp -r ./src/* $(PKG_BUILD_DIR)/ # 将源码copy到上述路径endef define Build/Configureendef define Build/Compileendef # 安装包所要做的全部事情define Package/$(PKG_NAME)/install# 设置固件中程序（helloworld）存放在 /usr/sbin/ 下$(INSTALL_DIR) $(1)/usr/sbin# (INSTALL_BIN) 相当于 cp 命令$(INSTALL_BIN) $(PKG_BUILD_DIR)/$(PKG_NAME) $(1)/usr/sbin/endef $(eval $(call BuildPackage,$(PKG_NAME))) # 必须有 ## define Package/$(PKG_NAME)/install # 可以使用 shell 命令，可操作性很高# 注意：每条shell语句只能一行写完，不能分行（注意 if/where/def 等也只能写一行）# # 修改文件前需要先创建该文件# 例如：往计划任务添加一行指令# touch $(1)/etc/crontabs/root# if [ `grep -c "/etc/init.d/network restart" $(1)/etc/crontabs/root` -eq '0' ]; then echo "* * * * * /etc/init.d/network restart &gt; /dev/null" &gt;&gt; $(1)/etc/crontabs/root; fi## 复制文件前需要先创建文件夹# 例如：创建 helloworld 的开机自启脚本（脚本内容同 linux，名称为helloworld, 路径为$(PKG_BUILD_DIR)/bin/helloworld）# mkdir -p $(1)/etc/init.d# cp $(PKG_BUILD_DIR)/bin/helloworld $(1)/etc/init.d/# 可以使用 cp -r 复制文件夹 在 make menuconfig 中选择 helloworld 程序 1234# 位置根据 整体 Makefile 中 define Package/$(PKG_NAME) 的 CATEGORY 定义make menuconfig* Utilities* helloworld 五、模块篇 添加 LONGSUNG U9300C 4G模块支持（ap147） 内核选项 1234567891011121314151617181920make kernel_menuconfigDevice Drives * Network device support * PPP(point-to-point protocol) support * PPP BSD-Compress compression * PPP Deflate compression * PPP filtering * PPP MPPE compression (encryption) * PPP multilink support * PPP over Ethernet * PPP support for async serial ports * PPP support for sync tty ports * SLIP (serial line) support * CSLIP compressed headers * USB Support * Support for Host-side USB * USB Modem (CDC ACM) support M USB Serial Converter support * USB Generic Serial Driver M USB driver for GSM and CDMA modems 编译选项 12345678910111213141516171819202122232425make menuconfigKernel modules USB Support * kmod-usb-acm * kmod-usb-net * * * * all * kmod-usb-net2280 * kmod-usb-ohci * kmod-usb-serial * * * * all * kmod-usb-uhci * kmod-usb-wdm * kmod-usb2 Network * WWAN * comgt * comgt-directip * comgt-ncm * uqmi * chat * ppp * umbim * wwan Utilities * usb-modeswitch 添加驱动支持 12345678910111213141516171819202122232425262728293031323334353637383940414243vim build_dir/target-mips_24kc_musl/linux-ar71xx_generic/linux-4.9.111/drivers/usb/serial/option.c// 添加 LONGSUNG U9300C 的 VID（0x1C9E）和PID（0x9B3C） #define LONGSUNG_VENDOR_ID 0x1C9E#define LONGSUNG_U9300_PRODUCT_ID 0x9B3C// 禁止 interface 4 加载驱动struct option_blacklist_info &#123; const unsigned long sendsetup; const unsigned long reserved;&#125;;static const struct option_blacklist_info longsung_u9300_blacklist = &#123; .reserved = BIT(4),&#125;;// 在 option_ids 数组中添加黑名单static const struct usb_device_id option_ids[] = &#123; &#123; USB_DEVICE(LONGSUNG_VENDOR_ID,LONGSUNG_U9300_PRODUCT_ID), .driver_info = (kernel_ulong_t)&amp;longsung_u9300_blacklist&#125;, ··· &#123; &#125;&#125;// 使用 usb-serial.ko 驱动的用户,需要在 usb-serial.c 文件中的 usb_serial_probe()函数中增加如下判断来过滤NDIS接口vim build_dir/target-mips_24kc_musl/linux-ar71xx_generic/linux-4.9.111/drivers/usb/serial/usb-serial.cstatic int usb_serial_probe(struct usb_interface *interface, const struct usb_device_id *id)&#123; ··· mutex_lock(&amp;table_lock); /*************LONGSUNG **************************/ if ((le16_to_cpu(dev-&gt;descriptor.idVendor) == 0x1C9E) &amp;&amp; (le16_to_cpu(dev-&gt;descriptor.idProduct) == 0x9B3C)) &#123; if(interface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber == 4) &#123; printk(KERN_INFO"Discover the 4th interface for U9300C NDIS.\n"); mutex_unlock(&amp;table_lock); return -ENODEV; &#125; &#125; ···&#125; 编译，刷写 验证 123456789101112131415161718# /dev/ 下出现 ttyUSB0-ttyUSB2 说明 U9300C 的驱动基本没问题# 注意：LONGSUNG U9300C 的串口中 AT(ttyUSB2)，Modem(ttyUSB1)可以发送 AT 命令，其它不能# 也可以通过在 Utilities --&gt; Termi --&gt; minicom 来调试cat /dev/ttyUSB2 &amp;# 查询版本信息echo AT+LCTSW &gt; /dev/ttyUSB2# 查询信号,将会得到信号强度和误码率信息echo AT+CSQ &gt; /dev/ttyUSB2# 查询注册状态echo AT+CREG? &gt; /dev/ttyUSB2# 网络运营商信息echo AT+COPS? &gt; /dev/ttyUSB2# 上述几个命令有输出就没问题# 查询网络运营商中# 中国移动 -- "CHINA MOBILE"# 中国联通 -- "CHN-UNICOM"/"UNICOM"# 中国电信 -- "CHN-CT"killall cat 启动 12345678910111213141516vim /etc/config/network# 添加 电信-4Gconfig interface '34g-ppp0' option ifname 'ppp0' option proto '3g' option apn 'CTNET' option service 'umts' option dialnumber '*99#' option username 'ctnet@mycdma.cn' option password 'vnet.mobi' option device '/dev/ttyUSB1' option dns '114.114.114.114'# 实测：移动和联通同样可以使用上面的配置# 移动apn为 CMNET 联通apn为 3GNET 六、编译刷机篇 备份分区 1dd if=/dev/mtd5 of=/tmp/firmware_backup.bin 备份及恢复路由器配置文件 1234# 备份sysupgrade -b /tmp/back.tar.gz# 恢复sysupgrade -f /tmp/back.tar.gz 恢复出厂设置 1234# 删除 /overlay 分区信息并重启rm -rvf /overlay/* &amp;&amp; reboot# 或者使用 mtdmtd -r erase rootfs_data 编译菜单选择 1make menuconfig 编译内核选择 123# 注意：内核大小有限制，一般为 1472k# 过大会报 uImage is too big，不会生成 sysupgrade.bin 文件make kernel_menuconfig 编译 1234# 官方不建议以 root 用户进行编译# V=s 表示输出日志# -j1 表示单线程编译，线程数可以修改make V=s -j1 刷写固件 1mtd write openwrt.bin firmware TFTP刷写固件（要先确定地址） 1234567# 使用串口连接路由器并进入uboot# 仅适用于特定路由，参数需要修改# 第一段意思是上传固件到 0x80060000 地址# 第二段意思是从 0x9f050000 地址开始，擦除上传固件大小的内存# 第三段意思是把上传的固件刷入 0x9f050000 地址，长度为固件的大小# 第四段 重启tftp 0x80060000 firmware_backup.bin &amp;&amp;erase 0x9f050000 +$filesize&amp;&amp;cp.b $fileaddr 0x9f050000 $filesize&amp;&amp;re]]></content>
      <tags>
        <tag>openwrt</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件类型定义 DTD]]></title>
    <url>%2F2018%2F11%2F18%2F%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89-DTD%2F</url>
    <content type="text"><![CDATA[文档类型定义（DTD）可定义合法的XML文档构建模块 它使用一系列合法的元素来定义文档的结构 优点通过 DTD，每一个 XML 文件均可携带一个有关其自身格式的描述。 通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。 而您的应用程序也可使用某个标准的 DTD 来验证从外部接收到的数据。 您还可以使用 DTD 来验证您自身的数据。 声明DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用 内部声明假如 DTD 被包含在 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中： 1&lt;!DOCTYPE root-element [element-declarations]&gt; 例如 1234567891011121314&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget me this weekend&lt;/body&gt;&lt;/note&gt; 以上 DTD 解释如下： !DOCTYPE note (第二行)定义此文档是 note 类型的文档。 !ELEMENT note (第三行)定义 note 元素有四个元素：”to、from、heading,、body” !ELEMENT to (第四行)定义 to 元素为 “#PCDATA” 类型 !ELEMENT from (第五行)定义 from 元素为 “#PCDATA” 类型 !ELEMENT heading (第六行)定义 heading 元素为 “#PCDATA” 类型 !ELEMENT body (第七行)定义 body 元素为 “#PCDATA” 类型 外部声明假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中： 1&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt; 例如 12345678&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE note SYSTEM "note.dtd"&gt;&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt; note.dtd 12345&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt; XML构建模块XML 和 HTML文档主要的构建模块是元素标签 所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成： 元素 元素是 XML 以及 HTML 文档的主要构建模块。 HTML 元素的例子是 “body” 和 “table”。XML 元素的例子是 “note” 和 “message” 。元素可包含文本、其他元素或者是空的。空的 HTML 元素的例子是 “hr”、”br” 以及 “img” 例如： 12&lt;body&gt;some text&lt;/body&gt;&lt;message&gt;some text&lt;/message&gt; 属性 属性可提供有关元素的额外信息。 属性总是被置于某元素的开始标签中。属性总是以名称/值的形式成对出现的。下面的 “img” 元素拥有关于源文件的额外信息： 1&lt;img src="computer.gif" /&gt; 元素的名称是 “img”。属性的名称是 “src”。属性的值是 “computer.gif”。由于元素本身为空，它被一个 “ /“ 关闭 实体 实体是用来定义普通文本的变量。实体引用是对实体的引用。 大多数同学都了解这个 HTML 实体引用：”&amp;nbsp(破坏实体);”。这个”无折行空格”实体在 HTML 中被用于在某个文档中插入一个额外的空格。 当文档被 XML 解析器解析时，实体就会被展开。 例如: &amp;lt(破坏实体);的对应字符为&lt; &amp;gt(破坏实体);的对应字符为&gt; &amp;amp(破坏实体);的对应字符为&amp; &amp;quot(破坏实体);的对应字符为” &amp;apos(破坏实体);的对应字符为’ PCDATA PCDATA 的意思是被解析的字符数据（parsed character data）。 可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。 PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。 文本中的标签会被当作标记来处理，而实体会被展开。 不过，被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 &amp;amp(破坏实体);、&amp;lt(破坏实体); 以及 &amp;gt(破坏实体); 实体来分别替换它们。 CDATA CDATA 的意思是字符数据（character data）。 CDATA 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开 DTD元素在一个 DTD 中，元素通过元素声明来进行声明 元素声明使用下面的语法： 123&lt;!ELEMENT element-name category&gt;或&lt;!ELEMENT element-name (element-content)&gt; 空元素通过类别关键词EMPTY进行声明 123456&lt;!ELEMENT element-name EMPTY&gt;实例:&lt;!ELEMENT br EMPTY&gt;XML example:&lt;br /&gt; 只有 PCDATA 的元素通过圆括号中的 #PCDATA 进行声明： 123&lt;!ELEMENT element-name (#PCDATA)&gt;实例:&lt;!ELEMENT from (#PCDATA)&gt; 通过类别关键词 ANY 声明的元素，可包含任何可解析数据的组合： 123&lt;!ELEMENT element-name ANY&gt;实例:&lt;!ELEMENT note ANY&gt; 带有一个或多个子元素的元素通过圆括号中的子元素名进行声明： 123456&lt;!ELEMENT element-name (child1)&gt;或&lt;!ELEMENT element-name (child1,child2,...)&gt;实例:&lt;!ELEMENT note (to,from,heading,body)&gt; 当子元素按照由逗号分隔开的序列进行声明时，这些子元素必须按照相同的顺序出现在文档中。在一个完整的声明中，子元素也必须被声明，同时子元素也可拥有子元素。”note” 元素的完整声明是： 12345&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt; 声明只出现一次的元素 1234&lt;!ELEMENT element-name (child-name)&gt;实例:&lt;!ELEMENT note (message)&gt; 上面的例子声明了：message 子元素必须出现一次，并且必须只在 “note” 元素中出现一次 声明最少出现一次的元素 1234&lt;!ELEMENT element-name (child-name+)&gt;实例:&lt;!ELEMENT note (message+)&gt; 上面的例子中的加号（+）声明了：message 子元素必须在 “note” 元素内出现至少一次 声明出现零次或一次的元素 1234&lt;!ELEMENT element-name (child-name?)&gt;实例:&lt;!ELEMENT note (message?)&gt; 上面的例子中的问号(?)声明了：子元素 message 可在 “note” 元素内出现零次或一次 声明出现零次或多次的元素 1234&lt;!ELEMENT element-name (child-name*)&gt;实例:&lt;!ELEMENT note (message*)&gt; 上面的例子中的星号（*）声明了：子元素 message 可在 “note” 元素内出现零次或多次 声明“非···/即···”类型的内容 12实例:&lt;!ELEMENT note (to,from,header,(message|body))&gt; 声明混合型的内容 12实例:&lt;!ELEMENT note (#PCDATA|to|from|header|message)*&gt; 上面的例子声明了：”note” 元素可包含出现零次或多次的 PCDATA、”to”、”from”、”header” 或者 “message” DTD属性在 DTD 中，属性通过 ATTLIST 声明来进行声明 示例： 1234567&lt;!ATTLIST element-name attribute-name attribute-type attribute-value&gt;DTD 实例:&lt;!ATTLIST payment type CDATA &quot;check&quot;&gt;XML 实例:&lt;payment type=&quot;check&quot; /&gt; 属性的类型 类型 描述 CDATA 值为字符数据 (character data) (en1\ en2\ ..) 此值是枚举列表中的一个值 ID 值为唯一的 id IDREF 值为另外一个元素的 id IDREFS 值为其他 id 的列表 NMTOKEN 值为合法的 XML 名称 NMTOKENS 值为合法的 XML 名称的列表 ENTITY 值是一个实体 ENTITIES 值是一个实体列表 NOTATION 此值是符号的名称 xml: 值是一个预定义的 XML 值 默认属性值可用以下值 值 解释 值 属性的默认值 #REQUIRED 属性值是必需的 #IMPLIED 属性不是必需的 #FIXED value 属性值是固定的 例如： 123456DTD:&lt;!ELEMENT square EMPTY&gt;&lt;!ATTLIST square width CDATA &quot;0&quot;&gt;合法的 XML:&lt;square width=&quot;100&quot; /&gt; 在上面的例子中，”square” 被定义为带有 CDATA 类型的 “width” 属性的空元素。如果宽度没有被设定，其默认值为0 #REQUIRED语法 1&lt;!ATTLIST element-name attribute-name attribute-type #REQUIRED&gt;· 示例：12345678DTD:&lt;!ATTLIST person number CDATA #REQUIRED&gt;合法的 XML:&lt;person number=&quot;5677&quot; /&gt;非法的 XML:&lt;person /&gt; #IMPLED语法 1&lt;!ATTLIST element-name attribute-name attribute-type #IMPLIED&gt; 示例： 12345678DTD:&lt;!ATTLIST contact fax CDATA #IMPLIED&gt;合法的 XML:&lt;contact fax=&quot;555-667788&quot; /&gt;合法的 XML:&lt;contact /&gt; #FIXED语法 1&lt;!ATTLIST element-name attribute-name attribute-type #FIXED &quot;value&quot;&gt; 实例 12345678DTD:&lt;!ATTLIST sender company CDATA #FIXED &quot;Microsoft&quot;&gt;合法的 XML:&lt;sender company=&quot;Microsoft&quot; /&gt;非法的 XML:&lt;sender company=&quot;W3Schools&quot; /&gt; 列举属性值语法 1&lt;!ATTLIST element-name attribute-name (en1|en2|..) default-value&gt; 实例 1234567DTD:&lt;!ATTLIST payment type (check|cash) &quot;cash&quot;&gt;XML 例子:&lt;payment type=&quot;check&quot; /&gt;或&lt;payment type=&quot;cash&quot; /&gt; 如果您希望属性值为一系列固定的合法值之一，请使用列举属性值。(男|女) 元素&amp;属性xml中数据可以存储在子元素或属性中 例： 1234&lt;person sex="female"&gt; &lt;firstname&gt;Anna&lt;/firstname&gt; &lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; 12345&lt;person&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;firstname&gt;Anna&lt;/firstname&gt; &lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; 没有特别规定何时使用属性，以及何时使用子元素。 一些属性具有以下问题: 属性不能包含多个值（子元素可以） 属性不容易扩展（为以后需求的变化） 属性无法描述结构（子元素可以） 属性更难以操纵程序代码 属性值是不容易测试，针对DTD 如果您使用属性作为数据容器，最终的XML文档将难以阅读和维护。 尝试使用元素来描述数据。只有在提供的数据是不相关信息时我们才建议使用属性。 例外：唯一标识符ID 123456789101112131415&lt;messages&gt;&lt;note id="p501"&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt;&lt;note id="p502"&gt; &lt;to&gt;Jani&lt;/to&gt; &lt;from&gt;Tove&lt;/from&gt; &lt;heading&gt;Re: Reminder&lt;/heading&gt; &lt;body&gt;I will not!&lt;/body&gt;&lt;/note&gt;&lt;/messages&gt; 以上实例的XML文件中，ID是只是一个计数器，或一个唯一的标识符，来识别不同的音符，而不是作为数据的一部分。 在这里我想说的是，元数据（关于数据的数据）应当存储为属性，而数据本身应当存储为元素。 实体实体是用于定义引用普通文本或特殊字符的快捷方式的变量。 实体引用是对实体的引用。 实体可在内部或外部进行声明。 内部声明语法 12345678910&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;示例：DTD 实例:&lt;!ENTITY writer &quot;Donald Duck.&quot;&gt;&lt;!ENTITY copyright &quot;Copyright runoob.com&quot;&gt;XML 实例：&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt; 注意： 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。 外部声明语法 12345678910&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt;示例：DTD 实例&lt;!ENTITY writer SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;&lt;!ENTITY copyright SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;XML example:&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt; 验证当您试图打开某个 XML 文档时，XML 解析器有可能会产生错误。通过访问 parseError 对象，就可以取回引起错误的确切代码、文本甚至所在的行。 XML格式验证(菜鸟教程)]]></content>
      <tags>
        <tag>DTD</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚类]]></title>
    <url>%2F2018%2F10%2F10%2F%E8%81%9A%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Data Science and Big Data Analytics: Discovering, Analyzing, Visualizing and Presenting Data 的第四章 目的 查找相似的文件/网站/图片 使用实例：冗余网站、查重等 社交网络分析 网易云音乐推荐、Netflix个性化推荐 差异分析两个文本之间的相似度衡量 Hamming Distance (汉明距离) Distance Functions（距离函数） Jaccard similarity 相似性系数 Hamming Distance 汉明距离在信息理论中，Hamming Distance 表示两个等长字符串在对应位置上不同字符的数目，我们以 d(x, y) 表示字符串x和y之间的汉明距离。从另外一个方面看，汉明距离度量了通过替换字符的方式将字符串 x 变成 y 所需要的最小的替换次数。 123456789101112131415161718192021// 举例说明以下字符串间的汉明距离为：PETERPUGET is 3.karolinkathrin is 3. karolinkerstin is 3.10111011001001 is 2.21738962233796 is 3.123456234561 is 6.GE2324CS2423 is 4. Euclidean Distance 欧几里得度量（欧式距离）欧氏距离是指在 m 维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。m 维空间中两个点之间的真实距离（不管是一维还是二维、三维，都是代表着真实的距离）。 两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的欧氏距离为 在二维空间中欧氏距离计算公式为： 示例： 上图中各点的坐标为： p1 = (0, 2)p2 = (2, 0)p3 = (3, 1)p4 = (5, 1) 各点间欧氏距离为： P1 P2 P3 P4 P1 0 2.828 3.162 5.099 P2 2.828 0 1.414 3.162 P3 3.162 1.414 0 2 P4 5.099 3.162 2 0 Manhattan Distance 曼哈顿距离我们可以定义曼哈顿距离的正式意义为 L1 - 距离或城市区块距离，也就是在欧几里得空间的固定直角坐标系上两点所形成的线段对轴产生的投影的距离总和。例如在平面上，坐标（x1,y1）的点 P1 与坐标（x2, y2）的点 P2 的曼哈顿距离为：|x1-x2|+|y1-y2|，要注意的是，曼哈顿距离依赖座标系统的转度，而非系统在座标轴上的平移或映射。 两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的曼哈顿距离为 在二维空间中曼哈顿距离计算公式为： 示例： a1 = (2, 8)a2 = (6, 3) dist = |2-6| + |8-3| = 4+5 = 9 距离度量函数一个函数 d 是距离度量函数需要具备以下条件 非负，d(a, b) &gt;= 0 恒等，if (a==b) d(a, b) = 0 对称，d(a, b) = d(b, a) 三角不等式，d(a, b) &lt;= d(a, c) + d(c, b) 1. 聚类概述聚类：使用无监督学习对类似对象进行分组 监督学习：使用带有标签的物体无监督学习：使用不带标签的物体 聚类查找数据中的隐藏结构，基于属性的相似性，通常用于探索性分析且没有预测 什么是聚类针对一组数据对象做处理，使得组内的对象彼此相似（或相关）并且与其他组中的对象不同（或不相关），即组内距离最小化、组间距离最大化 对对象（受访者，产品，公司，变量等）进行分组，以便每个对象与类中的其他对象类似，并且与所有其他类中的对象不同。 示例： 我们可以用聚类干什么 确定集群的含义 解释如何使用集群 聚类设计注意事项： 异常值检测 相似度/距离测量 三个基本的问题： 如何衡量相似度？ 距离算法 如何形成集群？ 层次聚类（Hierarchical Clustering）、K-means算法等 有多少个集群？ 验证聚类，检查连个、三个、四个甚至更多集群的聚类解决方案 根据 “先验” 标准、实际判断、常识、理论基础和统计意义选择集群数 概念步骤： 确定要聚类的变量 确定是否存在集群。 需要验证集群在统计上是否不同且理论上有意义（可以分配逻辑名称） 初步决定要使用的集群数量 使用人口统计学，心理学等描述派生集群的特征 示例： 埃里克和他的朋友们聚会， 他们决定分享他们收藏的葡萄酒。问如何分类这些葡萄酒？ 列出葡萄酒的属性，在其中选择聚类特征变量。 在这种情况下，我们选择评级和价格 将表转换为散点图 我们可以说有两个集群：低评级和低价格、高评级和高价格 决定使用这两个集群 进行聚类 但是有一个异常值 2. 聚类的两种类型划分聚类（Partitional algorithms）：构造各种分区，然后按一些标准评估它们层次聚类（Hierarchical algorithms）：使用某个标准（通常为距离）创建对象集的层次分级 K-means（基于划分的聚类 Partitional algorithms）给定一组具有 n 个可测量属性的对象的数据集和集群的划分数量 k，该算法根据每个对象到这 k 个组的中心的邻近长度区分这 k 个组 采用迭代的重定位技术，尝试通过对象在划分间移动来改进划分。所谓重定位技术，就是当有新的对象加入簇或者已有对象离开簇的时候，重新计算簇的平均值作为中心（簇中对象各维向量的平均值），然后对对象进行重新分配。这个过程不断重复，直到各簇中对象不再变化为止。 使用示例： 聚类通常被应用于以属性作为标识的集群的分类 图像处理：对于安全图像，检查连续帧以区分修改 医疗：可以将患者按照先天因素分组 客户划分：销售团队区分具有相似行为和消费模式的客户 K-means的步骤概述： 选择 k 的值和聚类中心的初始猜测值 计算从每个数据点到每个聚类中心的距离，并将每个点分配给最近的类 从步骤2计算每个新定义的集群的聚类中心 重复步骤2和3，直到算法收敛（不发生更改） 示例1： 设置 k = 3 和初始聚类中心 点被分配给最近的类（根据点到聚类中心的距离分配） 计算新集群的聚类中心 重复第2、3步直到收敛当聚类中心不改变或聚类中心来回振荡时收敛（当一个或多个点与聚类中心距离相等时，可能会发生这种情况） 基本的 K-means 算法： 选择要确定的 K 个集群 随机选择 K 个对象作为初始聚类中心 重复 3 将每个对象分配给最近的集群 计算每个集群新的聚类中心 直到 集群中心没有变化（即聚类中心不再改变位置） 或者 没有对象更改其集群（我们也可以定义停止条件） 示例2： 算法：K-means 距离度量：Euclidean Distance 欧几里得度量（欧式距离） 确定集群的数量并随机设置相同数量的 k 个节点（聚类中心） 根据它们到 k 个节点的距离对所有对象进行聚类。 然后重新设置第1步产生的 k 个节点（聚类中心） 根据每个对象到k个节点的距离重新聚类 重新设置 k 个节点（聚类中心），即将k个节点移动到其集群的中心 重复步骤3和4，直到 k 个节点不改变位置 示例3： 现有学生成绩如下图： 绘制散点图如下： 初始化三个中心： 将每个学生分配到最近的中心： 重新计算第一个中心 (54, 42)、(70, 57)、(69, 61)、(68, 66)、(88, 71)、(89, 74)、(74, 72)、(83, 83) 的平均值为 (74.38, 65.75) 重新计算第二个中心 (41, 43)、(45, 50) 的平均值为 (43.00, 46.50) 重新计算第三个中心 (56, 55)、(58, 58)、(63, 64)、(48, 65)、(72, 79)、(60, 83)、(86, 91)、(92, 97)、 (94, 100) 的平均值为 (69.89, 76.89) 重新分配每个学生最近的中心 重新计算第一个中心 (70, 57)、(58, 58)、(69, 61)、(63, 64)、(68, 66)、(88, 71)、(89, 74)、(74, 72) 的平均值为 (72.38, 65.38) 重新计算第二个中心 (54, 42)、 (41, 43)、(45, 50) 、(56, 55)、(48, 65) 的平均值为 (48.80, 51.00) 重新计算第三个中心 (72, 79)、(60, 83)、(83, 83)、(86, 91)、(92, 97)、 (94, 100) 的平均值为 (81.17, 88.83) 重新分配每个学生最近的中心，重新计算第一个中心 (70, 57)、(69, 61)、(63, 64)、(68, 66)、(88, 71)、(74, 72)、(60, 83) 的平均值为 (70.29, 67.71) 重新计算第二个中心 (54, 42)、 (41, 43)、(45, 50) 、(56, 55)、(58, 58)、(48, 65) 的平均值为 (50.33, 52.17) 重新计算第三个中心 (89, 74)、(72, 79)、(83, 83)、(86, 91)、(92, 97)、 (94, 100) 的平均值为 (86.00, 87.33) 重新分配每个学生最近的中心，重新计算第一个中心为 (68.00, 68.86)、第二个中心为 (50.33, 52.17)、第三个中心为 (88.67, 86.00) 最终分组为： K-means 的局限性：非球形体 解决： 优缺点分析： 优点： 相对有效 通常终止于局部最优。 只能找到固定数量的簇的最佳解决方案。 无法找到所有可能解决方案中的最佳解决方案。 在确定性退火技术（deterministic annealing）和遗传算法（genetic algorithms）和可能找到全局最优解 缺点： 仅在定义平均值时适用，那么分类数据呢？ 需要事先指定 k，集群的数量 无法处理乱的数据和异常值 不适合发现具有非凸形状的集群 Hierarchical Clustering（层次聚类）层次结构通常用于组织信息，例如在门户网站中 示例1：雅虎 雅虎的层次结构是手动创建的，我们将专注于自动创建数据挖掘中的层次结构。 用于总结相似性度量的有用工具——树形图 树形图中两个对象之间的相似性表示为它们共享的最低内部节点的高度。 我们可以查看树形图以确定“正确”的簇数。 在这种情况下，两个高度分离的子树高度暗示了两个簇。 （很少出现这种情况） 示例2： 树形图的一个潜在用途是检测异常值 ，单个独立的分支暗示了与所有其他分支非常不同的数据点 示例3： 单连接算法（Single-Linkage） 我们从距离矩阵开始，该矩阵包含数据库中每对对象之间的距离。 示例4： 自下而上（凝聚）：从其自己的集群中的每个项目开始，找到要合并到新集群中的最佳对。 重复，直到所有集群都融合在一起。 什么是好的聚类算法 一个好的聚类算法将产生具有组内相似度高、组间相似度低的集群 准确定义聚类算法的质量很困难，通常是依赖应用的并且是主观的 为什么要使用聚类 它的主要任务是探索性数据挖掘，也是统计数据分析的常用技术，可以应用于许多领域以及现实生活中 实际上，聚类是最常用的数据挖掘技术之一。它历史悠久，几乎用于各个领域，如工程，科学，医学，心理学，植物学，社会学，生物学，考古学，市场营销，保险，图书馆等 举例 为不同高度、不同体重的人制作大中小型号的衣服（XS、S、M、L、XL、XXL 等） 为所有人定制太贵，一刀切又不适合所有人 在营销中，根据客户的相似性对客户进行细分。做针对性的营销 给定一组文本文档，我们希望根据它们的内容相似性来组织它们，生成主题层次结构（书店中书的排列） 实际应用 便于理解：相关文档及参考文献，具有相似功能的基因组和蛋白质，或具有相似价格波动的股票组 概要展示：减小大数据集的大小。天气预报中的气温图、降雨图 例1：人群（物体）的划分 辛普森一家和学校的员工 男和女 例2： 3. 如何确定集群的最佳数量 合理的猜测 预定义的要求 使用启发式方法 - 例如，内部平方和（WSS） WSS度量是每个数据点与最近聚类中心之间的距离的平方和识别 k 的适当值的过程被称为找到 WSS 曲线的拐点（WSS为纵坐标，集群数量为横坐标） 曲线的拐点发生在 K = 3 的时候 检验 当集群的数量很小时，绘制数据有助于改进 k 的选择 需要注意 集群是否完全分离？ 所有集群中都只有少量的对象？ 所有集群的聚类中心是不是太接近了？ 选择理由和注意事项 需要做决定 分析中应该包含对象的哪些属性？ 每个属性应该使用哪种度量单位？ 属性是否需要重新调整？ 可能还有哪些其他需要考虑的因素？ 了解要知道哪些属性才能把新对象分配给集群 客户满意度可用于建模，但不适用于潜在客户 尽可能减少属性数量 多属性可以最大限度地减少关键变量的影响 找出高度相关的属性 将几个属性合并为一个：例如，债务/资产比率 例如：7个属性的散点图矩阵如下： 计量单位 K-means 将根据度量单位识别不同的集群 示例： 身高使用 cm 为单位 身高使用 m 为单位 重新调整可以减少统治效果 例如，将每个变量除以适当的标准偏差 其它考虑因素 K-means对初始聚类中心敏感（替换聚类中心重新运行几次） 可以探索欧氏距离以外的其它度量算法，如汉明距离、曼哈顿距离、马氏距离（Mahalanobis distance） K-means 适用于数字数据，并且不适用于名词属性，如性别，种族，血型，单词，形状，水果…… 4. R语言指令12345678# K-means 聚类算法kmeans()# K-modes 聚类算法kmod()# Partitioning around Medoids (PAM) 算法pam()# Hierarchical agglomerative clustering 层次聚类hclust() 5. 总结 聚类根据对象的属性对类似对象进行分组 要正确聚类，重要的是 正确缩放属性值以避免压迫（覆盖） 确保指定距离的概念是有意义的 仔细选择群集数量 识别出集群后，以描述性方式标记集群通常很有用 6. 高中生聚类分析]]></content>
      <tags>
        <tag>聚类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HMAC算法]]></title>
    <url>%2F2018%2F10%2F09%2FHMAC%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在密码学中，（消息认证码）Message Authentication Code 是用来认证消息的比较短的信息。换言之，MAC用来保证消息的数据完整性和消息的数据源认证 MAC由消息本身和一个密钥经过一系列计算产生，用于生成MAC的算法，称为MAC算法。 MAC算法应能满足如下几个条件: 在仅有消息本身没有密钥的情况下，无法得到该消息的 MAC 同一个消息在使用不同密钥的情况下，生成的 MAC 应当无关联 在已有一系列消息以及其 MAC 时，给定一个新的消息，无法得到该消息的 MAC 上图为维基百科上 MAC 算法使用示例。 HMACHMAC（Hash-based Message Authentication Code，哈希消息认证码）利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出 HMAC 是 IP 安全里必须实现的 MAC 方案，并且其他 Internet 协议中（如SSL）也使用了 HMAC。 HMAC的设计目标 可以直接使用现成的 Hash 函数 很容易用更好地 Hash 函数替代原来嵌入的 Hash 函数 能够保持 Hash 函数的原有性能，不能过分降低其性能 对密钥的使用和处理应较简单 如果已知嵌入的 Hash 函数的强度，完全可以知道认证机制抗密码分析的强度 正是 HMAC 的这些设计目标保证了HMAC的灵活性、可用性和扩展性，从而得到了广泛的支持。 定义 HMAC 需要一个加密用散列函数（表示为 H，可以是 MD5 或者 SHA-1）和一个密钥 K。我们用 B 来表示数据块的字节数。（以上所提到的散列函数的分割数据块字长 B=64），用 L 来表示散列函数的输出数据字节数（MD5 中 L=16, SHA-1 中 L=20）。鉴别密钥的长度可以是小于等于数据块字长的任何正整数值。应用程序中使用的密钥长度若是比 B 大，则首先用使用散列函数 H 作用于它，然后用 H 输出的L长度字符串作为在 HMAC 中实际使用的密钥。 一般情况下，推荐的最小密钥 K 长度是 L 个字节。 算法表示算法公式 ： HMAC( K, M ) = H( K⊕Opad | H( K⊕Ipad | M) ) H 代表所采用的HASH算法(如SHA-256) K 代表认证密钥 Ko 代表HASH算法的密文 M 代表一个消息输入 B 代表H中所处理的块大小，这个大小是处理块大小，而不是输出 hash 的大小 如，SHA-1 和 SHA-256 B = 64 SHA-384 和 SHA-512 B = 128 L 表示 hash 的大小 Opad 用 0x5c 重复 B 次 Ipad 用 0x36 重复 B 次 Apad 用 0x878FE1F3 重复 (L/4) 次 HMAC运算步骤First-Hash = H( Ko XOR Ipad || (data to auth) ) Second-Hash = H( Ko XOR Opad || First-Hash) 在密钥 K 后面添加0来创建一个字长为 B 的字符串。(例如，如果 K 的字长是20字节，B=64 字节，则K后会加入44个零字节0x00) 将上一步生成的 B 字长的字符串与 ipad 做异或运算 将数据流 text 填充至第二步的结果字符串中 用 H 作用于第三步生成的数据流 将第一步生成的 B 字长字符串与 opad 做异或运算 再将第四步的结果填充进第五步的结果中 用 H 作用于第六步生成的数据流，输出最终结果 HMAC的应用HMAC 主要应用在身份验证中，它的使用方法是这样的： 客户端发出登录请求（假设是浏览器的GET请求） 服务器返回一个随机值，并在会话中记录这个随机值 客户端将该随机值作为密钥，用户密码进行 HMAC 运算，然后提交给服务器 服务器读取用户数据库中的用户密码和步骤2中发送的随机值做与客户端一样的 HMAC 运算，然后与用户发送的结果比较，如果结果一致则验证用户合法 在这个过程中，可能遭到安全攻击的是服务器发送的随机值和用户发送的 HMAC 结果，而对于截获了这两个值的黑客而言这两个值是没有意义的，绝无获取用户密码的可能性。 随机值的引入使 HMAC 只在当前会话中有效，大大增强了安全性和实用性。 参考链接Message authentication code MAC与HMAC介绍 HMAC]]></content>
      <tags>
        <tag>安全协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DH(Diffie–Hellman)算法]]></title>
    <url>%2F2018%2F10%2F09%2FDH-Diffie%E2%80%93Hellman-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[DH 是 Diffie-Hellman的首字母缩写，是Whitefield与Martin Hellman在1976年提出了一个的密钥协商协议。其安全性源于在有限域上计算离散对数。该算法可以使两个用户之间安全地交换一个密钥，但不能用于加密或解密信息。 原理： Alice和Bob首先约定好公开的一种颜色，比如黄色 Alice和Bob各自挑选出一种私密的颜色，比如橙色和青色 Alice和Bob各自将两种颜色混合起来 双方交换混合后的颜色 Alice和Bob各自将自己的私密颜色再次混入得到的颜色中 现在Alice和Bob得到了一种相同的颜色，这种颜色是由一份黄色、一份橙色、一份青色混合而来，但外界无法得知 颜色混合是一种“不可逆”的操作，当双方交换颜色时，尽管我们知道他们交换的颜色都是由一份黄色和另一份其他颜色混合得到的，但我们还是无法或者很难得到他们的私密颜色。而DH秘钥交换的原理非常相似，也是利用了数学上的一个“不可逆”的运算，就是离散对数 乘方得逆运算称为对数运算，比如已知 7^x = 49 那么可知 x = log7 49 = 2 对数运算非常容易，即使在数字很大的时候是，但如果是下面的情况 7^x mod 13 = 8 求X的过程称为“离散对数”，就不那么容易了，在数字很大时几乎是一个不可能的运算，而DH秘钥交换就是利用了这种离散对数计算非常困难的特性来设计的。 公式里的mod是取模运算，取模运算有几条基本的定律如下 (a+b) mod P = (a mod P + b mod P) mod P (ab) mod P = (a mod P b mod P) mod P (a^b) mod P = ((a mod P)^b) mod P 根据上面的公式，可以推导出一个非常重要的公式 (G^(a*b)) mod P = (G^a mod P)^b mod P = (G^b mod P)^a mod P 根据这个公式，我们可以向上面交换颜色那样设计出一个秘密交换数字的流程出来 A和B首先约定两个公开的质数 p 和 g A和B各自随机产生两个数 a, b，作为自己的私钥 各自计算出自己的公钥 A, B A = g^a mod p B = g^b mod p 交换公钥 A, B 计算出加密用的密钥S Sa=B^a mod p=(g^b mod p)^a mod p=g^(a*b) mod p Sb=A^b mod p=(g^a mod p)^b mod p=g^(a*b) mod p 最终两个人得到的秘密数字都是 g^(ab) mod p，而窃听者仅从p, g, A, B四个公开信息，是无法得到这个秘密数字的 举个例子，假如 p=23，g=5，Alice选取的秘密数字 a=6，那么 A=5^6 mod 23=8，Bob选取的秘密数字是 b=15，那么 B=5^15 mod 23=19，交换A和B后，Alice计算出的密钥 Sa=19^6 mod 23=2，Bob计算出的密钥 Sb=8^15 mod 23=2当然，实际运算中不可能取这么小的数值，比如如果需要128bit长度的密钥，那么p值需要是128bit长度的质数，由于有模运算，所获得的密钥不会大于p，所以p值可以是128bit数字中最大的一个质数，g可以随便设置一个小的质数即可。 缺点如果注意的是，为了防止应用优化算法计算上述问题，质数p不是随便选择的，需要符合一定的条件。 随机数a、b的生成算法也必需注意，应使结果尽可能随机，不能出现可预测的规律，否则会使破解变的容易。 通过上述计算过程也可以看出DH算法不仅可以应用在2方通信的情况，如果多方通信，也可以使用该算法。 DH密钥交换算法无法验证对方身份，所以DH密钥交换算法不能抵御中间人攻击 DH算法中间人攻击原理： 从其原理之中可以看出，a，b 值并没有什么关系，a，b不能证明通信双方Alice与Bob的身份，这使得重放攻击可以轻易产生。 假设一个攻击者 Tom，当 Alice 向 Bob 发送 g, p, A 时，Tom 截获了信息，并（假装自己是 Bob）向 Alice 发送了 T=g^t mod p，其中 t 是 Tom 的私钥。同时 Tom（假装自己是 Alice）向 Bob 发送 g，p，T=g^t mod p，这样 Bob 以为这是 Alice 发过来的，就向 T 发送了 B=g^b mod p。 在 Alice 与 Tom 之间，创建的密钥就是 Sta=g^at mod p，两方密钥相同。 在 Tom 与 Bob 之间，创建的密钥就是 Stb=g^tb mod p，两方密钥相同。 这样，密钥创建完成，Alice 与 Bob 都认为自己与对方分享了只有他们两人所知的密钥，实际上并不是。当 Alice 想要发信息给 Bob 时，Alice 就会将信息用 Sta=g^at mod p 加密后发出，消息 Bob 无法解密，但会被 Tom 收到并解密，这样 Tom 可以或者扣留信息，或者篡改信息用 Stb=g^tb mod p 加密后发给 Bob，这样 Bob 会收到他认为是 Alice 发来的，其实是 Tom 发过来的经过篡改的信息。这样重放攻击就产生了。 解决： 可以采用数据签名技术解决中DH密钥交换过程中可能存在的中间人攻击 参考链接链接： DH密钥交换（Diffie–Hellman key exchange）算法笔记 一个简单的DH密钥协商算法的实现 Diffie–Hellman key exchange 关于Diffie-Hellman密钥协商机制以及中间人攻击]]></content>
      <tags>
        <tag>安全协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂算法]]></title>
    <url>%2F2018%2F10%2F09%2F%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[平方乘算法RSA 加解密中存在指数运算 X^a。通常解密运算中的指数非常大，a 的二进制位数通常会大于等于1024 bit，即可能 a &gt;= 2^1024。如果用一般方法直接计算 X^a 的值， 即 X*X*X……需要的运算量非常大，很容易溢出。 定义：MUL 为乘法运算即乘以 X，sq 为平方运算 考虑一个例子计算 X^8，则最简单的方法需要8次乘法运算 而更快捷的方法只需要3次平方运算在看一个更一般的例子，计算 X^24，最简单的方法就是计算24次乘法。 更有效的方法如下：即一次平方操作，一次乘法操作(乘以 X)，之后再三次平放操作。 即5次操作即可得到结果也就是说对于指数运算两种基本操作就可以得到结果：对当前结果平方，当前结果与 X 相乘。问题是如何确定平方与乘法的执行顺序, 平方-乘算法就可以解决这个问题。 大致描述为： 对 X^a 将指数 a 表示为2进制形式，高bit在左，然后从左至右扫描对应的 bit 位。除了最左边的 bit（MSB）以外，在扫描之后每个 bit 位时对当前结果平方，如果该bit位为1，则需多进行一次乘法操作 以计算 X^24 为例： 黑体表示二进制形式 X^24 将指数表示为二进制形式 X^11000 表示为 X^b1b2b3b4b5 开始扫描指数的每个Bit: 初始值 X = X^1; 初始化设置，b1 = 1，扫描第一个bit时不需要做其他操作 X^2 = X^11 b2=1，先平方 X^2*X = X^3 = X11 ，再乘以 X (X^3)^2 = X^6 = X^110 b3= 0，只需要一次平方 (X^6)^2 = X^12 = X^1100 b4 = 0，只需要一次平方 (X^12)^2 = X^24 = X^11000 b5 = 0,只需一次平方 通过观察运算过程中指数的二进制表示的变化能更好的理解算法，一次平方操作会让指数向左移一位，并在最右边添加0，而与 X 相乘的操作即在指数的最右边位置上填上 1 快速幂算法所谓的快速幂，实际上是快速幂取模的缩写，简单的说，就是快速的求一个幂式的模(余)。在程序设计过程中，经常要去求一些大数对于某个数的余数，为了得到更快、计算范围更大的算法，产生了快速幂取模算法。 快速幂实现基于引理：积的取余等于取余的积的取余，即： (a * b) mod n=(a mod n * b mod n) mod n 示例：4^24 mod 102 = 52 24 = 11000 4^24 mod 102 = ( ( ( ( (4^1)*(4^1)^2 ) ^2) ^2) ^2) mod 102 ​ = ( ( ( 64 ^2) ^2) ^2) mod 102 ​ = ( ( ( 64 ^2) ^2) mod 102) ^2 mod 102 ​ = ( ( ( 64 ^2) mod 102)^2 mod 102) ^2 mod 102 ​ = ( ( 256 mod 102)^2 mod 102) ^2 mod 102 ​ = ( 52^2 mod 102) ^2 mod 102 ​ = ( 52^2) mod 102 ​ = 52]]></content>
      <tags>
        <tag>密码学</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 详解（一） 网络基础知识]]></title>
    <url>%2F2018%2F09%2F30%2FTCP-IP-%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1. 计算机网络发展计算机发展是从独立模式到网络互连模式的。 ​ 独立模式：单机模式，指计算机未连接网络，各自独立使用的方式 ​ 网络互联模式：将计算机连在一起，形成一个计算机网络，信息共享、传递消息等 计算机网络按规模划分（定义比较宽泛） ​ WAN（Wide Area Network，广域网）：覆盖多个远距离区域的远程网络 ​ MAN（Metropolitan Area Network，城域网）：连接一个城市的网络 ​ LAN（Local Area Network，局域网）：一幢楼、一个学校等 计算机网络发展的7个阶段 批处理（Batch Processing）：20世纪50年代，事先将用户程序及数据装入卡带或磁带，并由计算机按照一定顺序读取，使用户所执行的这些程序和数据能够一并批量得到处理的方式（脱机、多道、成批处理） 分时系统（Time Sharing System，TSS）：20世纪60年代，多个终端与同一计算机连接，允许多个用户同时使用一台计算机。系统采用时间片轮转的办法在客观效果上用户批次感觉不到对方也在使用这台计算机，好像只有自己独占这台计算机一样（独占性、星型、交互性、多路性、及时性），计算机与终端进行连接（计算机与计算机之间并没有互相连接） 这里的终端由输入输出设备（显示器、键鼠等）组成 计算机之间的通信：20世纪70年代，计算机与计算机之间通信，传输数据，提高了计算机的可用性 计算机网络的产生：20实际80年代，能够连接多种计算机（异构）的网络产生，窗口系统发明并与网络结合 -&gt; 网上冲浪 窗口系统的发明使用户可以同时执行多个程序，还可以在这些程序之间自由的切换作业 互联网的普及：20实际90年代，一人一机（成本不菲），推出“瘦身”、“多供应商连接”。E-mail，WWW等信息传播方式迎来了前所未有的发展 瘦身：用“轻量型”个人电脑或UNIX工作站取代大型主机，降低网络架构成本 多供应商连接：将各种软硬件供应商的产品组合起来搭建网络，降低网络环境成本（异构型计算机之间的连接） 以互联网为中心：2000年，从电话网到IP网 建立连接 -&gt; 安全建立连接（完善）：2010年，随着互联网的普及，网络安全问题愈发突出，建立连接发展为安全建立连接 年代 内容 20世纪50年代 批处理时代 20世纪60年代 分时系统时代 20世纪70年代 计算机通信时代 20世纪80年代 计算机网络时代 20世纪90年代 互联网普及时代 2000年 以互联网为中心时代 2010年 无论何时何地一切皆TCP/IP的网络时代 2. 网络通信协议TCP/IP协议是通信协议的统称 计算机网络最初的目的是连接一个个独立的计算机，使他们组成一个更强有力的计算环境（提高生产力），现代计算的首要目的之一是连接人与人，事置身于世界各地的人门可以通过网络建立联系、相互沟通、交流思想 协议就是计算机与计算机之间通过网络实现通信通信时事先达成的一种“约定”。不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间只要遵循相同的协议就能够实现通信。相当于语言 协议可以分为很多种，每一种协议都明确地界定了它的行为规范。两台计算机之间必须能够支持相同的协议，并 遵循相同协议进行处理，这样才能实现相互通信。 CPU: Central Processing Unit, 中央处理器。每个程序实际上是由它调度执行的，CPU的性能很大程度上也决定着一台计算机的处理性能。 一个CPU通常在同一时间只能运行一个程序。为了让多个程序同时运行，操作系统采用CPU时间片轮转机制，在多个程序之间进行切换，合理调度 协议如同人与人之间的交流方式 分组交换协议分组交换是指将大数据分割成一个个叫做包（Packet）的较小单位进行传输的方法 计算机通信会在每一个分组中附加上源主机地址和目标主机地址送给通信线路，这些发送端地址、接收端地址以及分组序号写入的部分称为报文首部。接收端根据分组序号将每个分组按照序号重新分配为原始数据 通信协议中，通常会规定报文首部应该写入哪些信息、应该如何处理这些信息。分组发送方和接收方有必要对报文首部和内容保持一致的定义和解释 协议的标准化ISO（International Organization for Standards，国际标准化组织）制定了一个国际标准OSI（Open Systems Interconnection，开放式通信系统互联参考模型），对通信协议进行标准化（OSI协议没有得到普及，OSI参考模型经常被应用于网络协议的指定中） OSI协议是为了让异构的计算机之间能够相互通信的、由ISO和ITU- T推进其标准化的一种网络体系结构 TCP/IP协议由IETF（Internet Engineering Task Force）标准化 协议的分层与OSI参考模型协议的分层 OSI参考模型将通信协议必要的功能分为了7层。在这一模型中，每个分层都接收由它下一层所提供的特定服务。上下层之间进行交互时所遵循的约定叫做接口。同一层之间的交互所遵循的约定叫做协议。 分层的优势：分层可以将每个分层独立使用，即使系统中某些分层发生变化，也不会波及整个系统。因此，可以构造一个扩展性和灵活性都较强的系统。此外，通过分层能够细分通信功能，更易于单独实现每个分层的协议，并界定各个分层的具体责任和义务。 分层的劣势：过分模块化、使处理变得更加沉重以及每个模块都不得不实现相似的处理逻辑等问题。 OSI参考模型 OSI参考模型中各个分层的作用 应用层：为应用程序提供服务并规定应用程序中通信相关细节。包括文件传输、电子邮件、远程登录（虚拟终端）等协议。 表示层：主要负责数据格式的转换。具体来说，就是将设备固有的数据格式转换为网络标准传输格式。不同设备对同一比特流解释的结果可能会不同。因此，使它们保持一致是这一层的主要作用。 会话层：负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理 传输层：起着可靠传输的作用。只在通信双方节点上进行处理，而无需在路由器上处理 网络层：将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择 数据链路层：负责物理层面上互连的、节点之间的通信传输；将0、1序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收） 物理层：负责0、1比特流（0、1序列）与电压的高低、光的闪灭之间的转换 例子：A向B发送电子邮件 7层通信 会话层以上的处理 应用层：A新建邮件，指定收件人为B，并输入内容，点击发送邮件之后就会进入应用层协议处理。该协议会在所要处理的数据前端添加一个首部（标签）信息。B收到邮件后，分析数据首部与数据正文 表示层：将数据从某个计算机特定的数据格式转换为网络通用的标准数据格式再发出去。接收端接收后将数据恢复为该计算机特定的数据格式，然后再处理（例如转为 UTF-8） 会话层：决定采用何种连接方式是会话层的主要责任 传输层一下的处理 传输层：进行建立连接或断开连接的处理（会话层决定建立连接 和断开连接的时机，传输层进行实际的建立连接和断开连接），在两个主机间创建逻辑上的通信连接是传输层的主要作用，还会负责重发。保证数据传输的可靠性 网络层：将数据传输给对端（根据目的地址，整体） 数据链路层、物理层：将数据传输给对端（根据MAC地址，一个分段） 传输方式大致分为面向有连接与无连接两种类型面向无连接：以太网、IP、UDP协议等面向有链接：ATM、帧中继、TCP协议等 面向无连接：无需确认对端是否存在，发送端可随时发送数据 面向有连接：在通信传输之前，先打开一个连接，连接被关闭是无法传输数据 面向有连接型中，在发送数据之前，需要在收发主机之间连接一条通信线路（在不同的分层协议中，连接的具体含义可能有所不同。在数据链路层中的连接，就是指物理的、通信线路的连接。而传输层则负责创建与管理逻辑上的连接。）， 好比电话，输入对方号码拨出之后，只有对端拿起电话才能真正通话，通话结束之后将电话机扣上就如同切断电源。 面向无连接型不要求建立和断开连接。发送端可于任何时候自由发送数据，但接收端不知道自己会在什么时候接收数据，所以，接收端需要常常确认是否收到了数据。类似于寄包裹。即使不知道对端是否存在或能否接收数据，发送端也能将数据发送出去。 电路交换与分组交换目前，网络通信方式大致为两种——电路交换和分组交换。电路交换主要用于过去的电话网。TCP/IP技术采用了分组交换技术。 电路交换：交换机负责数据的中转处理。计算机之间发送数据时，需要通过交换机与目标主机建立通信电路。我们将连接电路称为建立连接。建立好连接后，用户可以一直使用这条电路，知道该连接被断开（独占）。当有一条电路连接了多台计算机时，某一台计算机在收发信息时会独占整个电路，其他计算机只能等待这台计算机处理结束以后才有机会使用这条电路收发数据。并且在此过程中，谁也无法预测某一台计算机的数据传输从何时开始又在何时结束。如果并发用户数超过交换机之间的通信线路数，就意味着通信根本无法实现。 分组交换：让连接到通信电路的计算机将所要发送的数据分成多个数据包，按照一定的顺序排列之后分别发送。这就是分组交换。有了分组交换，数据被细分后，所有的计算机就可以一齐收发数据，这样也就提高了通信线路的利用率。由于在分组的过程中，已经在每个分组的首部写入了发送端和接收端的地址，所以即使同一条线路同时为多 个用户提供服务，也可以明确区分每个分组数据发往的目的地，以及它是与哪台计算机进行的通信。 在分组交换 中，由分组交换机（路由器）连接通信线路。分组交换的大致处理过程是：发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，缓存到自己的缓冲区，然后再转发给目标 计算机。因此，分组交换也有另一个名称：蓄积交换。 路由器接收到数据以后会按照顺序缓存到相应的队列当中，再以先进先出的顺序将它们逐一发送出去（有时，也会优先发送目标地址比较特殊的数据）。 在分组交换中，计算机与路由器之间以及路由器与路由器之间通常只有一条通信线路。因此，这条线路其实是一条 共享线路。在电路交换中，计算机之间的传输速度不变。然而在分组交换中，通信线路的速度可能会有所不同。根据网络拥堵的情况，数据达到目标地址的时间有长有短。另外，路由器的缓存饱和或溢出时，甚至可能会发生分组数据丢失、无法发送到对端的情况。 根据接收端数量分类单播（Unicast）：1对1通信，固定电话 广播（Broadcast）：1对多，电视播放。广播范围-广播域 多播（Multicast）：1对多，但是要限制接收端，电话会议（需要限定成员） 任播（Anycast）：1对1，在一堆客户端中选取最适合的一个进行通信，DNS根域名解析服务器。 地址每一层协议使用的地址都不相同。 TCP/IP通信中使用MAC地址、IP地址、端口号等信息作为地址标识。在应用层可以将电子邮件地址作为网络通信地址 地址应具有唯一性：在同一通信网络中不允许有两个相同地址的通信主体存在 地址具有层次性：地址总数越来越多的时候，为了高效快速的找出通信地址的目标地址将成为一个重要的问题。IP地址具有层次性，MAC地址不具有。 IP地址的分层：IP地址由网络号和主机号两部分组成。即使通信主体的IP地址不同，若主机号不同、网络号相同，说明他们处于同一网段。通常，同处于一个网段的主机也都属于同一个部门或集团组织，另一方面， 网络号相同的主机在组织结构、提供商类型和地域分布上都比较集中，也为 IP 寻址带来了极大的方便（聚合性） 网络传输中，每个节点会根据分组数据的地址信息，来判断该报文应该由哪个网卡发送出去。为此，各个地址会参考一个发出接口列表。在这一点上MAC寻址与IP寻址是一样的。只不过MAC寻址中所参考的这张表叫做地址转发表，而IP寻址中所参考的叫做路由控制表，目前地址转发表和路由控制表并不需要在网络中的各个节点上手动设置， 而是由这些节点自动生成的。 地址转发表根据自学自动 成。 路由控制表则根据路由协议自动生成。 MAC地址转发表中所记录的是实际的MAC地址本身，而路由表中记录的IP地址则是集中了之后的网络号（确切的说，是网络号与子网掩码）。 网络的构成要素介绍连接计算机与计算机的硬件设备。 设备 作用 网卡 使计算机联网的设备（Network Interface） 中继器（Repeater） 从物理层上延长网络的设备 网桥（Bridge）/2层交换机 从数据链路层上延长网络的设备 路由器（Router）/3层交换机 从网络层转发分组数据的设备 4-7层交换机 处理传输层以上各层网络传输的设备 网关（Gateway） 转换协议的设备 网卡（网络接口卡，NIC） 中继器（Repeater）：中继器（Repeater）是在OSI模型的第1层——物理层面上延长网络的设备。由电缆传过来的电信号或光信号经由中继器的波形调整和放大再传给另一个电缆。 一般情况下，中继器的两端连接的是相同的通信媒介，但有的中继器也可以完成不同媒介之间的转接工作，但是这种中继器只能单纯的负责信号在0、1比特流之间的转换，并不负责判断数据是否有错误 有些中继器可以提供多个端口服务。这种中继器被称作中继集线器或集线器。因此，集线器（中继集线器也可以简称为集线器或Hub）也可以看作是多口中继器 网桥：网桥是在OSI模型的第2层——数据链路层面上连接两个网络的设备。它能够识别数据链路层中的数据帧（与分组数据意思大致相同，但是在数据链路层中通常习惯称为帧），并将这些数据帧临时存储于内存，再重新生成信号作为一个全新的帧转发给相连的另一个网段]]></content>
      <tags>
        <tag>TCP/IP详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F27%2FHello-World%2F</url>
    <content type="text"><![CDATA[1234567#include &lt;stdio.h&gt;int main(void)&#123; printf("Hello World\n"); return 0;&#125;]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
