<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>鱼 | 一条咸鱼</title>

  
  <meta name="author" content="HaooJie">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="鱼"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="鱼" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">鱼</a>
    </h1>
    <p class="site-description">一条咸鱼</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/12/05/openwrt踩坑/"><span>openwrt踩坑</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/12/05/openwrt踩坑/" rel="bookmark">
        <time class="entry-date published" datetime="2018-12-05T10:59:56.000Z">
          2018-12-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="OpenWrt踩坑"><a href="#OpenWrt踩坑" class="headerlink" title="OpenWrt踩坑"></a>OpenWrt踩坑</h2><ol>
<li><p>默认添加iptables规则</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim package/network/config/firewall/files/firewall.user</span><br><span class="line">+		iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o tun0 -j MASQUERADE</span><br></pre></td></tr></table></figure>
</li>
<li><p>允许包转发</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim package/network/config/firewall/files/firewall.config</span><br><span class="line">config defaults</span><br><span class="line">		option syn_flood	1</span><br><span class="line">		option input		ACCEPT</span><br><span class="line">		option output		ACCEPT</span><br><span class="line">-/+		option forward		ACCEPT		# 允许转发</span><br></pre></td></tr></table></figure>
</li>
<li><p>开机自启</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim package/base-files/files/etc/rc.local</span><br><span class="line">+		/etc/init.d/cron enable</span><br><span class="line">+		/etc/init.d/cron start</span><br></pre></td></tr></table></figure>
</li>
<li><p>WiFi默认开启、SSID修改</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim package/kernel/mac80211/files/lib/wifi/mac80211.sh</span><br><span class="line">-/+		set wireless.radio$&#123;devidx&#125;.disabled=0				# 0-默认开启 1-默认关闭</span><br><span class="line">-/+		set wireless.default_radio$&#123;devidx&#125;.ssid=AP-TEST	# SSID</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看分区</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/mtd</span><br><span class="line"></span><br><span class="line">dev:    size   erasesize  name</span><br><span class="line">mtd0: 00080000 00010000 "u-boot"</span><br><span class="line">mtd1: 00170000 00010000 "kernel"</span><br><span class="line">mtd2: 00e00000 00010000 "rootfs"</span><br><span class="line">mtd3: 00900000 00010000 "rootfs_data"</span><br><span class="line">mtd4: 00010000 00010000 "art"</span><br><span class="line">mtd5: 00f70000 00010000 "firmware"</span><br><span class="line">mtd6: 01000000 00010000 "all"</span><br></pre></td></tr></table></figure>
</li>
<li><p>备份分区</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/mtd5 of=/tmp/firmware_backup.bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>备份及恢复路由器配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 备份</span><br><span class="line">sysupgrade -b /tmp/back.tar.gz</span><br><span class="line"><span class="meta">#</span> 恢复</span><br><span class="line">sysupgrade -f /tmp/back.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复出厂设置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 删除 /overlay 分区信息并重启</span><br><span class="line">rm -rvf /overlay/* &amp;&amp; reboot</span><br><span class="line"><span class="meta">#</span> 或者使用 mtd</span><br><span class="line">mtd -r erase rootfs_data</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷写固件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtd write openwrt.bin firmware</span><br></pre></td></tr></table></figure>
</li>
<li><p>TFTP刷写固件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 使用串口连接路由器并进入uboot</span><br><span class="line"><span class="meta">#</span> 仅适用于特定路由，参数需要修改</span><br><span class="line"><span class="meta">#</span> 第一段意思是上传固件到 0x80060000 地址</span><br><span class="line"><span class="meta">#</span> 第二段意思是从 0x9f050000 地址开始，擦除上传固件大小的内存</span><br><span class="line"><span class="meta">#</span> 第三段意思是把上传的固件刷入 0x9f050000 地址，长度为固件的大小</span><br><span class="line"><span class="meta">#</span> 第四段 重启</span><br><span class="line">tftp 0x80060000 firmware_backup.bin &amp;&amp;erase 0x9f050000 +$filesize&amp;&amp;cp.b $fileaddr 0x9f050000 $filesize&amp;&amp;re</span><br></pre></td></tr></table></figure>
</li>
<li><p>喂狗</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">vim build_dir/target-mips_24kc_musl/linux-ar71xx_generic/linux<span class="number">-4.9</span><span class="number">.111</span>/arch/mips/ath79/mach-ap147.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AP147_GPIO_XWDT 17	<span class="comment">// watchdog gpio</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XWDT_AUTOFEED_DURATION          (HZ / 3)	<span class="comment">// 喂狗时间</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> gpio_external_wdt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> wdt_timeout = <span class="number">-1</span>, wdt_autofeed_count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">watchdog_fire</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">watchdog_ticktock</span> = <span class="title">TIMER_INITIALIZER</span>(<span class="title">watchdog_fire</span>, 0, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">external_wdt_toggle</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> u32 data;</span><br><span class="line">        data ++;</span><br><span class="line">        gpio_set_value(gpio_external_wdt, data &amp; <span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">watchdog_fire</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(wdt_timeout &gt; <span class="number">0</span>)</span><br><span class="line">                wdt_autofeed_count++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((wdt_timeout &lt; <span class="number">0</span>) || (wdt_autofeed_count &lt; wdt_timeout)) &#123;</span><br><span class="line">                external_wdt_toggle();</span><br><span class="line">                mod_timer(&amp;watchdog_ticktock, jiffies + XWDT_AUTOFEED_DURATION);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enable_external_wdt</span><span class="params">(<span class="keyword">int</span> gpio)</span> </span>&#123;</span><br><span class="line">        printk(<span class="string">"register watchdog init\n"</span>);</span><br><span class="line">        gpio_external_wdt = gpio;</span><br><span class="line">        wdt_timeout = <span class="number">-1</span>;</span><br><span class="line">        mod_timer(&amp;watchdog_ticktock, jiffies + XWDT_AUTOFEED_DURATION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">ap147_setup</span><span class="params">(vodi)</span> </span>&#123;</span><br><span class="line">     ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);</span><br><span class="line">     ath79_gpio_output_select(AP147_GPIO_XWDT, <span class="number">0</span>);</span><br><span class="line">     enable_external_wdt(AP147_GPIO_XWDT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看分区</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cmdline</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改分区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim target/linux/ar71xx/image/legacy.mk</span><br><span class="line">-/+		ap147_mtdlayout=mtdparts=...	</span><br><span class="line">    	<span class="comment">// 改成想要的分区，如果修改了顺序，需要修改下一处的最后一个单词 RKuImage, 按修改后的顺序填写</span></span><br><span class="line">-/+		$(eval $(call SingleProfile,AthLzma,<span class="number">64</span>k,AP147_010,ap147<span class="number">-010</span>,AP147<span class="number">-010</span>,ttyS0,<span class="number">115200</span>,$$(ap147_mtdlayout),KRuImage))</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改默认LAN IP</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim package/base-files/files/bin/config_generate</span><br><span class="line">case "protocol" in</span><br><span class="line">	static)</span><br><span class="line">		local ipad</span><br><span class="line">		case "$1" in</span><br><span class="line">-/+			lan) ipad=$&#123;ipaddr:-"192.168.1.1"&#125; ;;	# 改这里</span><br><span class="line">			*) ipad=$&#123;ipaddr:-"192.168.$((addr_offset++)).1"&#125; ;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改LUCI界面初始化的小字 及 首页URL</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vim feeds/luci/modules/luci-base/root/www/index.html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></span><br><span class="line">-/+             <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0; URL=/cgi-bin/luci/login"</span> /&gt;</span>	<span class="comment">&lt;!-- 你想要的首页的URL --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"background-color: white"</span>&gt;</span></span><br><span class="line">            	<span class="comment">&lt;!-- 你想要的首页的URL --&gt;</span></span><br><span class="line">            	<span class="comment">&lt;!-- 你想要的提示 --&gt;</span></span><br><span class="line">-/+             <span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">"color: black; font-family: arial, helvetica, sans-serif;"</span> <span class="attr">href</span>=<span class="string">"/cgi-bin/luci/login"</span>&gt;</span>欢迎登录xxx<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加自己的程序 - HelloWorld（含依赖库的helloworld程序）</p>
<ul>
<li>创建hellloworld包</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd package</span><br><span class="line">mkdir helloworld</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目录如下</span></span><br><span class="line">helloworld/</span><br><span class="line">├── Makefile		<span class="comment">// Helloworld.ipk 的整体 Makefile;</span></span><br><span class="line">└── src				<span class="comment">// 源程序</span></span><br><span class="line">    ├── main.c		<span class="comment">// 源文件</span></span><br><span class="line">    └── Makefile	<span class="comment">// 源 MakeFile</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>源文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim helloworld/src/main.c </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sodium_init() == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;		<span class="comment">// 依赖库，测试是否包含libsodium</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n********************************\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"          hello world!          \n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"********************************\n\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>源Makefile</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vim helloworld/src/Makefile </span><br><span class="line"></span><br><span class="line">OBJECTS=helloworld</span><br><span class="line">LIBS += -lsodium</span><br><span class="line"></span><br><span class="line">all:$(OBJECTS)</span><br><span class="line">	PKG_NAME=docs</span><br><span class="line"></span><br><span class="line">helloworld:main.o</span><br><span class="line"><span class="meta">	$</span>(CC) $(LDFLAGS) $(LIBS) -std=c99 $^ -o $@</span><br><span class="line"></span><br><span class="line">main.o:main.c</span><br><span class="line"><span class="meta">	$</span>(CC) $(CFLAGS) -std=c99  -c $&lt;</span><br><span class="line"></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">	@-rm *.o  helloworld</span><br></pre></td></tr></table></figure>
</li>
<li><p>整体Makefile</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">vim helloworld/Makefile </span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span># Copyright (C) 2014 OpenWrt.org</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span># This is free software, licensed under the GNU General Public License v2.</span><br><span class="line"><span class="meta">#</span> See /LICENSE for more information.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line">include $(TOPDIR)/rules.mk	# 必须</span><br><span class="line"></span><br><span class="line">PKG_NAME:=helloworld	# 包名</span><br><span class="line">PKG_VERSION:=1.0		# 版本号</span><br><span class="line">PKG_RELEASE:=1			# 构建号</span><br><span class="line"></span><br><span class="line">include $(INCLUDE_DIR)/package.mk	# 必须</span><br><span class="line"></span><br><span class="line">PKG_BUILD_DIR:=$(BUILD_DIR)/$(PKG_NAME)-$(PKG_VERSION)	# 构建包的路径</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 包的简介以及 menuconfig 的位置</span><br><span class="line">define Package/$(PKG_NAME)</span><br><span class="line">	SECTION:=utils</span><br><span class="line">	CATEGORY:=Utilities</span><br><span class="line">	TITLE:=helloworld  -- a Test Program</span><br><span class="line">	DEPENDS:=+libsodium		# 依赖库</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 包的描述，可以为空</span><br><span class="line">define Package/$(PKG_NAME)/description</span><br><span class="line">	a test program, Hello World!</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 构建包之前的准备，可以为空，会自动创建</span><br><span class="line">define Build/Prepare</span><br><span class="line">	mkdir -p $(PKG_BUILD_DIR)			# 创建 构建包的路径</span><br><span class="line">	cp -r ./src/* $(PKG_BUILD_DIR)/		# 将源码copy到上述路径</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">define Build/Configure</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">define Build/Compile</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装包所要做的全部事情</span><br><span class="line">define Package/$(PKG_NAME)/install</span><br><span class="line"><span class="meta">	#</span> 设置固件中程序（helloworld）存放在 /usr/sbin/ 下</span><br><span class="line"><span class="meta">	$</span>(INSTALL_DIR) $(1)/usr/sbin</span><br><span class="line"><span class="meta">	#</span> (INSTALL_BIN) 相当于 cp 命令</span><br><span class="line"><span class="meta">	$</span>(INSTALL_BIN) $(PKG_BUILD_DIR)/$(PKG_NAME) $(1)/usr/sbin/</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span>(eval $(call BuildPackage,$(PKG_NAME)))	# 必须有</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> define Package/$(PKG_NAME)/install </span><br><span class="line"><span class="meta">#</span> 可以使用 shell 命令，可操作性很高</span><br><span class="line"><span class="meta">#</span> 注意：每条shell语句只能一行写完，不能分行（注意 if/where/def 等也只能写一行）</span><br><span class="line"><span class="meta">#</span> </span><br><span class="line"><span class="meta">#</span> 修改文件前需要先创建该文件</span><br><span class="line"><span class="meta">#</span> 例如：往计划任务添加一行指令</span><br><span class="line"><span class="meta">#</span>	touch $(1)/etc/crontabs/root</span><br><span class="line"><span class="meta">#</span>	if [ `grep -c "/etc/init.d/network restart" $(1)/etc/crontabs/root` -eq '0' ]; then echo "* * * * * /etc/init.d/network restart &gt; /dev/null" &gt;&gt; $(1)/etc/crontabs/root; fi</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> 复制文件前需要先创建文件夹</span><br><span class="line"><span class="meta">#</span> 例如：创建 helloworld 的开机自启脚本（脚本内容同 linux，名称为helloworld, 路径为$(PKG_BUILD_DIR)/bin/helloworld）</span><br><span class="line"><span class="meta">#</span> 	mkdir -p $(1)/etc/init.d</span><br><span class="line"><span class="meta">#</span> 	cp $(PKG_BUILD_DIR)/bin/helloworld $(1)/etc/init.d/</span><br><span class="line"><span class="meta">#</span> 可以使用 cp -r 复制文件夹</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 make menuconfig 中选择 helloworld 程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 位置根据 整体 Makefile 中 define Package/$(PKG_NAME) 的 CATEGORY 定义</span><br><span class="line">make menuconfig</span><br><span class="line">	* Utilities</span><br><span class="line">		* helloworld</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>编译内核</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 注意：内核大小有限制，一般为 1472k</span><br><span class="line"><span class="meta">#</span> 过大会报 uImage is too big，不会生成 sysupgrade.bin 文件</span><br><span class="line">make kernel_menuconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p>LONGSUNG U9300C 4G支持（ap147）</p>
<ul>
<li><p>内核选项</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">make kernel_menuconfig</span><br><span class="line">Device Drives</span><br><span class="line">	* Network device support</span><br><span class="line">		* PPP(point-to-point protocol) support</span><br><span class="line">			* PPP BSD-Compress compression</span><br><span class="line">			* PPP Deflate compression</span><br><span class="line">			* PPP filtering</span><br><span class="line">			* PPP MPPE compression (encryption)</span><br><span class="line">			* PPP multilink support</span><br><span class="line">			* PPP over Ethernet</span><br><span class="line">			* PPP support for async serial ports</span><br><span class="line">			* PPP support for sync tty ports</span><br><span class="line">		* SLIP (serial line) support</span><br><span class="line">		* CSLIP compressed headers</span><br><span class="line">	* USB Support</span><br><span class="line">		* Support for Host-side USB</span><br><span class="line">		* USB Modem (CDC ACM) support</span><br><span class="line">		M USB Serial Converter support</span><br><span class="line">			* USB Generic Serial Driver</span><br><span class="line">			M USB driver for GSM and CDMA modems</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译选项</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">Kernel modules</span><br><span class="line">	USB Support</span><br><span class="line">		* kmod-usb-acm</span><br><span class="line">		* kmod-usb-net</span><br><span class="line">			* * * * all</span><br><span class="line">		* kmod-usb-net2280</span><br><span class="line">		* kmod-usb-ohci</span><br><span class="line">		* kmod-usb-serial</span><br><span class="line">			* * * * all</span><br><span class="line">		* kmod-usb-uhci</span><br><span class="line">		* kmod-usb-wdm</span><br><span class="line">		* kmod-usb2</span><br><span class="line">	Network</span><br><span class="line">		* WWAN</span><br><span class="line">			* comgt</span><br><span class="line">			* comgt-directip</span><br><span class="line">			* comgt-ncm</span><br><span class="line">			* uqmi</span><br><span class="line">		* chat</span><br><span class="line">		* ppp</span><br><span class="line">		* umbim</span><br><span class="line">		* wwan</span><br><span class="line">	Utilities</span><br><span class="line">		* usb-modeswitch</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加驱动支持</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">vim build_dir/target-mips_24kc_musl/linux-ar71xx_generic/linux<span class="number">-4.9</span><span class="number">.111</span>/drivers/usb/serial/option.c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 LONGSUNG U9300C 的 VID（0x1C9E）和PID（0x9B3C） </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LONGSUNG_VENDOR_ID                      0x1C9E</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LONGSUNG_U9300_PRODUCT_ID               0x9B3C</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止 interface 4 加载驱动</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option_blacklist_info</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> sendsetup;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> reserved;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option_blacklist_info</span> <span class="title">longsung_u9300_blacklist</span> = &#123;</span></span><br><span class="line">        .reserved = BIT(<span class="number">4</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 option_ids 数组中添加黑名单</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">option_ids</span>[] = &#123;</span></span><br><span class="line">    &#123; USB_DEVICE(LONGSUNG_VENDOR_ID,LONGSUNG_U9300_PRODUCT_ID),</span><br><span class="line">                .driver_info = (<span class="keyword">kernel_ulong_t</span>)&amp;longsung_u9300_blacklist&#125;,</span><br><span class="line">    	···</span><br><span class="line">	&#123;	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 usb-serial.ko 驱动的用户,需要在 usb-serial.c 文件中的 usb_serial_probe()函数中增加如下判断来过滤NDIS接口</span></span><br><span class="line">vim build_dir/target-mips_24kc_musl/linux-ar71xx_generic/linux<span class="number">-4.9</span><span class="number">.111</span>/drivers/usb/serial/usb-serial.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> usb_serial_probe(struct usb_interface *interface,</span><br><span class="line">                               <span class="keyword">const</span> struct usb_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">    ···</span><br><span class="line">    mutex_lock(&amp;table_lock);</span><br><span class="line">    <span class="comment">/*************LONGSUNG **************************/</span></span><br><span class="line">    <span class="keyword">if</span> ((le16_to_cpu(dev-&gt;descriptor.idVendor) == <span class="number">0x1C9E</span>) &amp;&amp;</span><br><span class="line">        (le16_to_cpu(dev-&gt;descriptor.idProduct) == <span class="number">0x9B3C</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(interface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber == <span class="number">4</span>) &#123;</span><br><span class="line">            printk(KERN_INFO<span class="string">"Discover the 4th interface for U9300C NDIS.\n"</span>);</span><br><span class="line">            mutex_unlock(&amp;table_lock);</span><br><span class="line">            <span class="keyword">return</span> -ENODEV;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译，刷写</p>
</li>
<li><p>验证</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> /dev/ 下出现 ttyUSB0-ttyUSB2 说明 U9300C 的驱动基本没问题</span><br><span class="line"><span class="meta">#</span> 注意：LONGSUNG U9300C 的串口中 AT(ttyUSB2)，Modem(ttyUSB1)可以发送 AT 命令，其它不能</span><br><span class="line"><span class="meta">#</span> 也可以通过在 Utilities --&gt; Termi --&gt; minicom 来调试</span><br><span class="line">cat /dev/ttyUSB2 &amp;</span><br><span class="line"><span class="meta">#</span> 查询版本信息</span><br><span class="line">echo AT+LCTSW &gt; /dev/ttyUSB2</span><br><span class="line"><span class="meta">#</span> 查询信号,将会得到信号强度和误码率信息</span><br><span class="line">echo AT+CSQ &gt; /dev/ttyUSB2</span><br><span class="line"><span class="meta">#</span> 查询注册状态</span><br><span class="line">echo AT+CREG? &gt; /dev/ttyUSB2</span><br><span class="line"><span class="meta">#</span> 网络运营商信息</span><br><span class="line">echo AT+COPS? &gt; /dev/ttyUSB2</span><br><span class="line"><span class="meta">#</span> 上述几个命令有输出就没问题</span><br><span class="line"><span class="meta">#</span> 查询网络运营商中</span><br><span class="line"><span class="meta">#</span> 中国移动 	-- 	"CHINA MOBILE"</span><br><span class="line"><span class="meta">#</span> 中国联通 	-- 	"CHN-UNICOM"/"UNICOM"</span><br><span class="line"><span class="meta">#</span> 中国电信	--	"CHN-CT"</span><br><span class="line">killall cat</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/config/network</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加 电信-4G</span><br><span class="line">config interface '34g-ppp0'</span><br><span class="line">        option ifname 'ppp0'</span><br><span class="line">        option proto '3g'</span><br><span class="line">        option apn 'CTNET'</span><br><span class="line">        option service 'umts'</span><br><span class="line">        option dialnumber '*99#'</span><br><span class="line">        option username 'ctnet@mycdma.cn'</span><br><span class="line">        option password 'vnet.mobi'</span><br><span class="line">        option device '/dev/ttyUSB1'</span><br><span class="line">        option dns '114.114.114.114'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 实测：移动和联通同样可以使用上面的配置</span><br><span class="line"><span class="meta">#</span> 移动apn为 CMNET 联通apn为 3GNET</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>添加/修改网络接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vim package/base-files/files/bin/config_generate</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认为电信4G</span></span><br><span class="line">generate_static_network() &#123;</span><br><span class="line">+	uci -q batch &lt;&lt;-EOF</span><br><span class="line">+		set network.ppp0='interface'</span><br><span class="line">+		set network.ppp0.ifname='34G'</span><br><span class="line">+		set network.ppp0.proto='3g'</span><br><span class="line">+ 		set network.ppp0.apn='CTNET'</span><br><span class="line">+		set network.ppp0.service='umts'</span><br><span class="line">+		set network.ppp0.dialnumber='*99#'</span><br><span class="line">+		set network.ppp0.username='ctnet@mycdma.cn'</span><br><span class="line">+		set network.ppp0.password='vnet.mobi'</span><br><span class="line">+		set network.ppp0.device='/dev/ttyUSB1'</span><br><span class="line">+		set network.ppp0.dns='114.114.114.114'</span><br><span class="line">+	EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止 root 登录SSH</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim package/network/services/dropbear/files/dropbear.config</span><br><span class="line"></span><br><span class="line">config dropbear</span><br><span class="line">        option PasswordAuth 'on'</span><br><span class="line">        option RootPasswordAuth 'off'</span><br><span class="line">        option Port         '22'</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加用户</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 按照相同格式在一下文件中添加记录</span><br><span class="line">vim package/base-files/files/etc/passwd</span><br><span class="line">vim package/base-files/files/etc/shadow</span><br><span class="line">vim package/base-files/files/etc/group</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 switch </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim target/linux/ar71xx/base-files/etc/board.d/02_network</span><br><span class="line"></span><br><span class="line">        ap143|\</span><br><span class="line">        rb-433|\</span><br><span class="line">        rb-433u)</span><br><span class="line">+/-             ucidef_set_interfaces_lan_wan &quot;eth1&quot; &quot;eth0&quot;</span><br><span class="line">                ucidef_add_switch &quot;switch0&quot; \</span><br><span class="line">                        &quot;1:lan&quot; &quot;2:lan&quot; &quot;5@eth1&quot;</span><br><span class="line">                ;;</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/openwrt/">openwrt</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/12/05/openwrt踩坑/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/01/K路归并算法/"><span>K路归并算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/01/K路归并算法/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-01T06:02:44.000Z">
          2018-11-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="K路归并排序"><a href="#K路归并排序" class="headerlink" title="K路归并排序"></a>K路归并排序</h2><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><p>将k个已经排序的数组归并成一个大的排序的结果数组（这些数组可能数量比较大，以至于不能直接装载到内存中）</p>
<h4 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h4><p>因为K个数组是已经排好序的，所以我们选取每个数组的第一个元素，这些元素中最小的那个就是所有元素中最小的那个。在该最小元素所在的数组中选取下一个元素进行比较，重复以上步骤，依次循环直到找到所有元素。</p>
<p>####解决方法：</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/排序/">排序</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/11/01/K路归并算法/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/10/聚类/"><span>聚类</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/10/聚类/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-10T14:55:07.000Z">
          2018-10-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="L3-聚类"><a href="#L3-聚类" class="headerlink" title="L3 聚类"></a>L3 聚类</h2><blockquote>
<p>Data Science and Big Data Analytics: Discovering, Analyzing, Visualizing and Presenting Data 的第四章</p>
</blockquote>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ol>
<li><p>查找相似的文件/网站/图片</p>
<p>使用实例：冗余网站、查重等</p>
</li>
<li><p>社交网络分析</p>
<p>网易云音乐推荐、Netflix个性化推荐</p>
</li>
</ol>
<h4 id="差异分析"><a href="#差异分析" class="headerlink" title="差异分析"></a>差异分析</h4><p>两个文本之间的相似度衡量</p>
<ol>
<li>Hamming Distance (汉明距离) </li>
<li>Distance Functions（距离函数）</li>
<li>Jaccard similarity 相似性系数</li>
</ol>
<h4 id="Hamming-Distance-汉明距离"><a href="#Hamming-Distance-汉明距离" class="headerlink" title="Hamming Distance 汉明距离"></a>Hamming Distance 汉明距离</h4><p>在信息理论中，Hamming Distance 表示两个等长字符串在对应位置上不同字符的数目，我们以 d(x, y) 表示字符串x和y之间的汉明距离。从另外一个方面看，汉明距离度量了通过替换字符的方式将字符串 x 变成 y 所需要的最小的替换次数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举例说明以下字符串间的汉明距离为：</span></span><br><span class="line">PETER</span><br><span class="line">PUGET is <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">karolin</span><br><span class="line">kathrin is <span class="number">3.</span></span><br><span class="line">    </span><br><span class="line">karolin</span><br><span class="line">kerstin is <span class="number">3.</span></span><br><span class="line"></span><br><span class="line"><span class="number">1011101</span></span><br><span class="line"><span class="number">1001001</span> is <span class="number">2.</span></span><br><span class="line"></span><br><span class="line"><span class="number">2173896</span></span><br><span class="line"><span class="number">2233796</span> is <span class="number">3.</span></span><br><span class="line"></span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="number">234561</span> is <span class="number">6.</span></span><br><span class="line"></span><br><span class="line">GE2324</span><br><span class="line">CS2423 is <span class="number">4.</span></span><br></pre></td></tr></table></figure>
<h4 id="Euclidean-Distance-欧几里得度量（欧式距离）"><a href="#Euclidean-Distance-欧几里得度量（欧式距离）" class="headerlink" title="Euclidean Distance 欧几里得度量（欧式距离）"></a>Euclidean Distance 欧几里得度量（欧式距离）</h4><p>欧氏距离是指在 m 维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。m 维空间中两个点之间的真实距离（不管是一维还是二维、三维，都是代表着真实的距离）。</p>
<p><strong>两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的欧氏距离为</strong> </p>
<p><img src="/2018/10/10/聚类/1353398777_7638.png" alt="img"></p>
<p>在二维空间中欧氏距离计算公式为：</p>
<p><img src="/2018/10/10/聚类/1353399552_4107.png" alt="img"></p>
<p>示例：</p>
<p><img src="/2018/10/10/聚类/1539160246010.png" alt="1539160246010"></p>
<p>上图中各点的坐标为：</p>
<p>p1 = (0, 2)<br>p2 = (2, 0)<br>p3 = (3, 1)<br>p4 = (5, 1)</p>
<p>各点间欧氏距离为：</p>
<table>
<thead>
<tr>
<th></th>
<th>P1</th>
<th>P2</th>
<th>P3</th>
<th>P4</th>
</tr>
</thead>
<tbody>
<tr>
<td>P1</td>
<td>0</td>
<td>2.828</td>
<td>3.162</td>
<td>5.099</td>
</tr>
<tr>
<td>P2</td>
<td>2.828</td>
<td>0</td>
<td>1.414</td>
<td>3.162</td>
</tr>
<tr>
<td>P3</td>
<td>3.162</td>
<td>1.414</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>P4</td>
<td>5.099</td>
<td>3.162</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<h4 id="Manhattan-Distance-曼哈顿距离"><a href="#Manhattan-Distance-曼哈顿距离" class="headerlink" title="Manhattan Distance 曼哈顿距离"></a>Manhattan Distance 曼哈顿距离</h4><p>我们可以定义曼哈顿距离的正式意义为 L1 - 距离或城市区块距离，也就是在欧几里得空间的固定直角坐标系上两点所形成的线段对轴产生的投影的距离总和。例如在平面上，坐标（x1,y1）的点 P1 与坐标（x2, y2）的点 P2 的曼哈顿距离为：|x1-x2|+|y1-y2|，要注意的是，曼哈顿距离依赖座标系统的转度，而非系统在座标轴上的平移或映射。</p>
<p><strong>两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的曼哈顿距离为 </strong> </p>
<p><img src="/2018/10/10/聚类/1353399924_2304.png" alt="img"></p>
<p>在二维空间中曼哈顿距离计算公式为：</p>
<p><img src="/2018/10/10/聚类/1353399908_7845.png" alt="img"></p>
<p>示例：</p>
<p><img src="/2018/10/10/聚类/1539161037816.png" alt="1539161037816"><img src="/2018/10/10/聚类/1539161207965.png" alt="1539161207965"></p>
<p>a1 = (2, 8)<br>a2 = (6, 3)</p>
<p>dist = |2-6| + |8-3| = 4+5 = 9</p>
<h4 id="距离度量函数"><a href="#距离度量函数" class="headerlink" title="距离度量函数"></a>距离度量函数</h4><p>一个函数 d 是距离度量函数需要具备以下条件</p>
<ol>
<li>非负，d(a, b) &gt;= 0</li>
<li>恒等，if (a==b) d(a, b) = 0</li>
<li>对称，d(a, b)  = d(b, a)</li>
<li>三角不等式，d(a, b) &lt;= d(a, c) + d(c, b)</li>
</ol>
<p><img src="/2018/10/10/聚类/1539161600701.png" alt="1539161600701"></p>
<h3 id="1-聚类概述"><a href="#1-聚类概述" class="headerlink" title="1. 聚类概述"></a>1. 聚类概述</h3><p>聚类：使用无监督学习对类似对象进行分组</p>
<p>监督学习：使用带有标签的物体<br>无监督学习：使用不带标签的物体</p>
<p>聚类查找数据中的隐藏结构，基于属性的相似性，<code>通常用于探索性分析且没有预测</code> </p>
<h4 id="什么是聚类"><a href="#什么是聚类" class="headerlink" title="什么是聚类"></a>什么是聚类</h4><p>针对<code>一组</code>数据对象做处理，使得<code>组内的对象彼此相似（或相关）</code>并且<code>与其他组中的对象不同（或不相关）</code>，即组内距离最小化、组间距离最大化</p>
<p><img src="/2018/10/10/聚类/1539162325797.png" alt="1539162325797"></p>
<p>对对象（受访者，产品，公司，变量等）进行分组，以便每个对象与类中的其他对象类似，并且与所有其他类中的对象不同。</p>
<p>示例：</p>
<p><img src="/2018/10/10/聚类/1539162699263.png" alt="1539162699263"></p>
<p>我们可以用聚类干什么</p>
<ol>
<li>确定集群的含义</li>
<li>解释如何使用集群</li>
</ol>
<p><strong>聚类设计注意事项：</strong> </p>
<ol>
<li>异常值检测</li>
<li>相似度/距离测量</li>
</ol>
<p>三个基本的问题：</p>
<ol>
<li><p>如何衡量相似度？</p>
<p>距离算法</p>
</li>
<li><p>如何形成集群？</p>
<p>层次聚类（Hierarchical Clustering）、K-means算法等</p>
</li>
<li><p>有多少个集群？</p>
<ul>
<li>验证聚类，检查连个、三个、四个甚至更多集群的聚类解决方案</li>
<li>根据 “先验” 标准、实际判断、常识、理论基础和统计意义选择集群数</li>
</ul>
</li>
</ol>
<p><strong>概念步骤：</strong> </p>
<ol>
<li>确定要聚类的变量</li>
<li>确定是否存在集群。 需要验证集群在统计上是否不同且理论上有意义（可以分配逻辑名称）</li>
<li>初步决定要使用的集群数量</li>
<li>使用人口统计学，心理学等描述派生集群的特征</li>
</ol>
<p>示例：</p>
<p>埃里克和他的朋友们聚会， 他们决定分享他们收藏的葡萄酒。问如何分类这些葡萄酒？</p>
<p><img src="/2018/10/10/聚类/1539163669601.png" alt="1539163669601"></p>
<ol>
<li><p>列出葡萄酒的属性，在其中选择聚类特征变量。 在这种情况下，我们选择评级和价格</p>
<p><img src="/2018/10/10/聚类/1539163864982.png" alt="葡萄酒属性"></p>
</li>
<li><p>将表转换为散点图</p>
<p><img src="/2018/10/10/聚类/1539166607835.png" alt="1539166607835"></p>
<p>我们可以说有两个集群：低评级和低价格、高评级和高价格</p>
</li>
<li><p>决定使用这两个集群</p>
</li>
<li><p>进行聚类</p>
<p><img src="/2018/10/10/聚类/1539166779783.png" alt="1539166779783"></p>
</li>
</ol>
<p>但是有一个异常值</p>
<h3 id="2-聚类的两种类型"><a href="#2-聚类的两种类型" class="headerlink" title="2. 聚类的两种类型"></a>2. 聚类的两种类型</h3><p>划分聚类（Partitional algorithms）：构造各种分区，然后按一些标准评估它们<br>层次聚类（Hierarchical algorithms）：使用某个标准（通常为距离）创建对象集的层次分级</p>
<p><img src="/2018/10/10/聚类/1539168431282.png" alt="1539168431282"></p>
<h4 id="K-means（基于划分的聚类-Partitional-algorithms）"><a href="#K-means（基于划分的聚类-Partitional-algorithms）" class="headerlink" title="K-means（基于划分的聚类 Partitional algorithms）"></a>K-means（基于划分的聚类 Partitional algorithms）</h4><p>给定一组具有 n 个可测量属性的对象的数据集和集群的划分数量 k，该算法根据每个对象到这 k 个组的中心的邻近长度区分这 k 个组</p>
<p>采用迭代的重定位技术，尝试通过对象在划分间移动来改进划分。所谓重定位技术，就是当有新的对象加入簇或者已有对象离开簇的时候，重新计算簇的平均值作为中心（簇中对象各维向量的平均值），然后对对象进行重新分配。这个过程不断重复，直到各簇中对象不再变化为止。</p>
<p>使用示例：</p>
<p>聚类通常被应用于以属性作为标识的集群的分类</p>
<ol>
<li>图像处理：对于安全图像，检查连续帧以区分修改</li>
<li>医疗：可以将患者按照先天因素分组</li>
<li>客户划分：销售团队区分具有相似行为和消费模式的客户</li>
</ol>
<p><strong>K-means的步骤概述：</strong> </p>
<ol>
<li>选择 k 的值和聚类中心的初始猜测值</li>
<li>计算从每个数据点到每个聚类中心的距离，并将每个点分配给最近的类</li>
<li>从步骤2计算每个新定义的集群的聚类中心</li>
<li>重复步骤2和3，直到算法收敛（不发生更改）</li>
</ol>
<p>示例1：</p>
<ol>
<li><p>设置 k = 3 和初始聚类中心</p>
<p><img src="/2018/10/10/聚类/1539170669025.png" alt="1539170669025"></p>
</li>
<li><p>点被分配给最近的类（根据点到聚类中心的距离分配）</p>
<p><img src="/2018/10/10/聚类/1539170717637.png" alt="1539170717637"></p>
</li>
<li><p>计算新集群的聚类中心</p>
<p><img src="/2018/10/10/聚类/1539170753121.png" alt="1539170753121"></p>
</li>
<li><p>重复第2、3步直到收敛<br>当聚类中心不改变或聚类中心来回振荡时收敛（当一个或多个点与聚类中心距离相等时，可能会发生这种情况）</p>
</li>
</ol>
<p>基本的 K-means 算法：</p>
<ol>
<li><p>选择要确定的 K 个集群</p>
</li>
<li><p>随机选择 K 个对象作为初始聚类中心</p>
<p>重复 3</p>
</li>
<li><ul>
<li>将每个对象分配给最近的集群</li>
<li>计算每个集群新的聚类中心</li>
</ul>
<p>直到</p>
</li>
<li><ul>
<li><p>集群中心没有变化（即聚类中心不再改变位置）</p>
<p>或者</p>
</li>
<li><p>没有对象更改其集群（我们也可以定义停止条件）</p>
</li>
</ul>
</li>
</ol>
<p><img src="/2018/10/10/聚类/1539171166690.png" alt="1539171166690"></p>
<p>示例2：</p>
<blockquote>
<p>算法：K-means </p>
<p>距离度量：Euclidean Distance 欧几里得度量（欧式距离）</p>
</blockquote>
<ol>
<li><p>确定集群的数量并随机设置相同数量的 k 个节点（聚类中心）</p>
<p><img src="/2018/10/10/聚类/1539171340715.png" alt="1539171340715"></p>
</li>
<li><p>根据它们到 k 个节点的距离对所有对象进行聚类。 然后重新设置第1步产生的 k 个节点（聚类中心）</p>
<p><img src="/2018/10/10/聚类/1539171457637.png" alt="1539171457637"></p>
</li>
<li><p>根据每个对象到k个节点的距离重新聚类</p>
<p><img src="/2018/10/10/聚类/1539171505050.png" alt="1539171505050"></p>
</li>
<li><p>重新设置 k 个节点（聚类中心），即将k个节点移动到其集群的中心</p>
<p><img src="/2018/10/10/聚类/1539171797117.png" alt="1539171797117"></p>
</li>
<li><p>重复步骤3和4，直到 k 个节点不改变位置</p>
<p><img src="/2018/10/10/聚类/1539171843507.png" alt="1539171843507"></p>
</li>
</ol>
<p>示例3：</p>
<p>现有学生成绩如下图：</p>
<p><img src="/2018/10/10/聚类/1539171929457.png" alt="1539171929457"></p>
<p>绘制散点图如下：</p>
<p><img src="/2018/10/10/聚类/1539172369783.png" alt="1539172369783"> </p>
<p>初始化三个中心：</p>
<p><img src="/2018/10/10/聚类/1539172399392.png" alt="初始化中心"></p>
<p>将每个学生分配到最近的中心：</p>
<p><img src="/2018/10/10/聚类/1539172658724.png" alt="对象划分"></p>
<p>重新计算第一个中心 (54, 42)、(70, 57)、(69, 61)、(68, 66)、(88, 71)、(89, 74)、(74, 72)、(83, 83) 的平均值为 (74.38, 65.75)</p>
<p><img src="/2018/10/10/聚类/1539172413813.png" alt="1539172413813"></p>
<p>重新计算第二个中心 (41, 43)、(45, 50) 的平均值为 (43.00, 46.50)</p>
<p><img src="/2018/10/10/聚类/1539172807489.png" alt="1539172807489"></p>
<p>重新计算第三个中心 (56, 55)、(58, 58)、(63, 64)、(48, 65)、(72, 79)、(60, 83)、(86, 91)、(92, 97)、 (94, 100) 的平均值为 (69.89, 76.89)</p>
<p><img src="/2018/10/10/聚类/1539172819316.png" alt="1539172819316"></p>
<p>重新分配每个学生最近的中心</p>
<p><img src="/2018/10/10/聚类/1539173397754.png" alt="1539173397754"></p>
<p>重新计算第一个中心 (70, 57)、(58, 58)、(69, 61)、(63, 64)、(68, 66)、(88, 71)、(89, 74)、(74, 72) 的平均值为 (72.38, 65.38)</p>
<p><img src="/2018/10/10/聚类/1539173529256.png" alt="1539173529256"></p>
<p>重新计算第二个中心 (54, 42)、 (41, 43)、(45, 50) 、(56, 55)、(48, 65) 的平均值为 (48.80, 51.00) </p>
<p><img src="/2018/10/10/聚类/1539173769853.png" alt="1539173769853"></p>
<p>重新计算第三个中心 (72, 79)、(60, 83)、(83, 83)、(86, 91)、(92, 97)、 (94, 100) 的平均值为 (81.17, 88.83)</p>
<p><img src="/2018/10/10/聚类/1539173839158.png" alt="1539173839158"></p>
<p>重新分配每个学生最近的中心，重新计算第一个中心 (70, 57)、(69, 61)、(63, 64)、(68, 66)、(88, 71)、(74, 72)、(60, 83) 的平均值为 (70.29, 67.71)</p>
<p><img src="/2018/10/10/聚类/1539174147613.png" alt="1539174147613"></p>
<p>重新计算第二个中心 (54, 42)、 (41, 43)、(45, 50) 、(56, 55)、(58, 58)、(48, 65) 的平均值为 (50.33, 52.17) </p>
<p><img src="/2018/10/10/聚类/1539174232313.png" alt="1539174232313"></p>
<p>重新计算第三个中心  (89, 74)、(72, 79)、(83, 83)、(86, 91)、(92, 97)、 (94, 100) 的平均值为 (86.00, 87.33)</p>
<p><img src="/2018/10/10/聚类/1539174304230.png" alt="1539174304230"></p>
<p>重新分配每个学生最近的中心，重新计算第一个中心为 (68.00, 68.86)、第二个中心为 (50.33, 52.17)、第三个中心为 (88.67, 86.00)</p>
<p><img src="/2018/10/10/聚类/1539174422971.png" alt="1539174422971"></p>
<p>最终分组为：</p>
<p><img src="/2018/10/10/聚类/1539174481077.png" alt="1539174481077">  </p>
<p><img src="/2018/10/10/聚类/1539174525500.png" alt="1539174525500"></p>
<p>K-means 的局限性：非球形体</p>
<p><img src="/2018/10/10/聚类/1539174620415.png" alt="1539174620415"> </p>
<p>解决：</p>
<p><img src="/2018/10/10/聚类/1539174675989.png" alt="1539174675989"></p>
<p><strong>优缺点分析：</strong></p>
<p>优点：</p>
<ol>
<li>相对有效</li>
<li>通常终止于<code>局部最优</code>。 只能找到<code>固定数量的簇</code>的最佳解决方案。 无法找到所有可能解决方案中的最佳解决方案。 在确定性退火技术（deterministic annealing）和遗传算法（genetic algorithms）和可能找到全局最优解</li>
</ol>
<p>缺点：</p>
<ol>
<li>仅在定义平均值时适用，那么分类数据呢？</li>
<li>需要事先指定 k，集群的数量</li>
<li>无法处理乱的数据和异常值</li>
<li>不适合发现具有<code>非凸形状</code>的集群</li>
</ol>
<h4 id="Hierarchical-Clustering（层次聚类）"><a href="#Hierarchical-Clustering（层次聚类）" class="headerlink" title="Hierarchical Clustering（层次聚类）"></a>Hierarchical Clustering（层次聚类）</h4><p><code>层次结构通常用于组织信息</code>，例如在门户网站中</p>
<p>示例1：雅虎</p>
<p><img src="/2018/10/10/聚类/1539175606413.png" alt="1539175606413"></p>
<p> <img src="/2018/10/10/聚类/1539175630740.png" alt="1539175630740"></p>
<p>雅虎的层次结构是手动创建的，我们将专注于自动创建数据挖掘中的层次结构。</p>
<p>用于总结相似性度量的有用工具——树形图</p>
<p><img src="/2018/10/10/聚类/1539175876186.png" alt="1539175876186"></p>
<p>树形图中两个对象之间的相似性表示为它们共享的最低内部节点的高度。</p>
<p><img src="/2018/10/10/聚类/1539175888083.png" alt="1539175888083"></p>
<p> 我们可以查看树形图以确定“正确”的簇数。 在这种情况下，两个高度分离的子树高度暗示了两个簇。 （很少出现这种情况）</p>
<p>示例2：</p>
<p><img src="/2018/10/10/聚类/1539176509082.png" alt="1539176509082"></p>
<p><img src="/2018/10/10/聚类/1539176708935.png" alt="1539176708935"></p>
<p>树形图的一个潜在用途是<code>检测异常值</code> ，单个独立的分支暗示了与所有其他分支非常不同的数据点</p>
<p>示例3：</p>
<p><img src="/2018/10/10/聚类/1539176885921.png" alt="1539176885921"></p>
<p><strong>单连接算法（Single-Linkage）</strong> </p>
<p>我们从距离矩阵开始，该矩阵包含数据库中每对对象之间的距离。</p>
<p>示例4：</p>
<p><img src="/2018/10/10/聚类/1539177224070.png" alt="1539177224070"></p>
<p><img src="/2018/10/10/聚类/1539177456161.png" alt="1539177456161"></p>
<p><img src="/2018/10/10/聚类/1539177472045.png" alt="1539177472045"></p>
<p>自下而上（凝聚）：从其自己的集群中的每个项目开始，找到要合并到新集群中的最佳对。 重复，直到所有集群都融合在一起。</p>
<p><img src="/2018/10/10/聚类/1539177604082.png" alt="1539177604082"></p>
<p><img src="/2018/10/10/聚类/1539177658924.png" alt="1539177658924"></p>
<p><img src="/2018/10/10/聚类/1539177769877.png" alt="1539177769877"></p>
<p><img src="/2018/10/10/聚类/1539177857273.png" alt="1539177857273"></p>
<h4 id="什么是好的聚类算法"><a href="#什么是好的聚类算法" class="headerlink" title="什么是好的聚类算法"></a>什么是好的聚类算法</h4><ul>
<li>一个好的聚类算法将产生具有组内相似度高、组间相似度低的集群</li>
<li>准确定义聚类算法的质量很困难，通常是依赖应用的并且是主观的</li>
</ul>
<h4 id="为什么要使用聚类"><a href="#为什么要使用聚类" class="headerlink" title="为什么要使用聚类"></a>为什么要使用聚类</h4><ul>
<li>它的主要任务是<code>探索性数据挖掘</code>，也是统计数据分析的常用技术，可以应用于许多领域以及现实生活中</li>
<li>实际上，聚类是最常用的数据挖掘技术之一。它历史悠久，几乎用于各个领域，如工程，科学，医学，心理学，植物学，社会学，生物学，考古学，市场营销，保险，图书馆等</li>
</ul>
<p><strong>举例</strong> </p>
<ol>
<li><p>为不同高度、不同体重的人制作大中小型号的衣服（XS、S、M、L、XL、XXL 等）</p>
<p>为所有人定制太贵，一刀切又不适合所有人</p>
</li>
<li><p>在营销中，根据客户的相似性对客户进行细分。做针对性的营销</p>
</li>
<li><p>给定一组文本文档，我们希望根据它们的内容相似性来组织它们，生成主题层次结构（书店中书的排列）</p>
<p><img src="/2018/10/10/聚类/1539179084020.png" alt="1539179084020"></p>
</li>
</ol>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><ol>
<li>便于理解：相关文档及参考文献，具有相似功能的基因组和蛋白质，或具有相似价格波动的股票组</li>
<li>概要展示：减小大数据集的大小。天气预报中的气温图、降雨图</li>
</ol>
<p>例1：人群（物体）的划分</p>
<p><img src="/2018/10/10/聚类/1539179560155.png" alt="1539179560155"></p>
<ol>
<li><p>辛普森一家和学校的员工</p>
<p><img src="/2018/10/10/聚类/1539179605410.png" alt="1539179605410"></p>
</li>
<li><p>男和女</p>
<p><img src="/2018/10/10/聚类/1539179662214.png" alt="1539179662214"></p>
</li>
</ol>
<p>例2：</p>
<p><img src="/2018/10/10/聚类/1539179725992.png" alt="1539179725992"></p>
<h3 id="3-如何确定集群的最佳数量"><a href="#3-如何确定集群的最佳数量" class="headerlink" title="3. 如何确定集群的最佳数量"></a>3. 如何确定集群的最佳数量</h3><ol>
<li><p>合理的猜测</p>
</li>
<li><p>预定义的要求</p>
</li>
<li><p>使用启发式方法 - 例如，内部平方和（WSS）</p>
<p>WSS度量是每个数据点与最近聚类中心之间的距离的平方和<br>识别 k 的适当值的过程被称为找到 WSS 曲线的拐点（WSS为纵坐标，集群数量为横坐标）</p>
<p><img src="/2018/10/10/聚类/1539180399694.png" alt="1539180399694"></p>
<p>曲线的拐点发生在 K = 3 的时候</p>
</li>
</ol>
<p><strong>检验</strong> </p>
<ol>
<li>当集群的数量很小时，绘制数据有助于改进 k 的选择</li>
<li>需要注意<ul>
<li>集群是否完全分离？</li>
<li>所有集群中都只有少量的对象？</li>
<li>所有集群的聚类中心是不是太接近了？</li>
</ul>
</li>
</ol>
<p><strong>选择理由和注意事项</strong> </p>
<ol>
<li><p>需要做决定</p>
<ul>
<li>分析中应该包含对象的哪些属性？</li>
<li>每个属性应该使用哪种度量单位？</li>
<li>属性是否需要重新调整？</li>
<li>可能还有哪些其他需要考虑的因素？</li>
</ul>
</li>
<li><p>了解要知道哪些属性才能把新对象分配给集群</p>
<p>客户满意度可用于建模，但不适用于潜在客户</p>
</li>
<li><p>尽可能减少属性数量</p>
<ul>
<li>多属性可以最大限度地减少关键变量的影响</li>
<li>找出高度相关的属性</li>
<li>将几个属性合并为一个：例如，债务/资产比率</li>
</ul>
<p>例如：7个属性的散点图矩阵如下：</p>
<p><img src="/2018/10/10/聚类/1539181338623.png" alt="1539181338623"></p>
</li>
<li><p>计量单位</p>
<p>K-means 将根据度量单位识别不同的集群</p>
<p>示例：</p>
<ul>
<li><p>身高使用 cm 为单位</p>
<p><img src="/2018/10/10/聚类/1539181465807.png" alt="1539181465807"></p>
</li>
<li><p>身高使用 m 为单位</p>
<p><img src="/2018/10/10/聚类/1539181524405.png" alt="1539181524405"></p>
</li>
</ul>
</li>
<li><p>重新调整可以减少统治效果</p>
<p>例如，将每个变量除以适当的标准偏差</p>
<p><img src="/2018/10/10/聚类/1539181892276.png" alt="1539181892276"></p>
</li>
<li><p>其它考虑因素</p>
<p>K-means对初始聚类中心敏感（替换聚类中心重新运行几次）</p>
<p>可以探索欧氏距离以外的其它度量算法，如汉明距离、曼哈顿距离、马氏距离（Mahalanobis distance）</p>
</li>
<li><p>K-means 适用于数字数据，并且不适用于名词属性，如性别，种族，血型，单词，形状，水果……</p>
</li>
</ol>
<h3 id="4-R语言指令"><a href="#4-R语言指令" class="headerlink" title="4. R语言指令"></a>4. R语言指令</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># K-means 聚类算法</span></span><br><span class="line">kmeans()</span><br><span class="line"><span class="comment"># K-modes 聚类算法</span></span><br><span class="line">kmod()</span><br><span class="line"><span class="comment"># Partitioning around Medoids (PAM) 算法</span></span><br><span class="line">pam()</span><br><span class="line"><span class="comment"># Hierarchical agglomerative clustering 层次聚类</span></span><br><span class="line">hclust()</span><br></pre></td></tr></table></figure>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ol>
<li>聚类根据对象的属性对类似对象进行分组</li>
<li>要正确聚类，重要的是<ul>
<li>正确缩放属性值以避免压迫（覆盖）</li>
<li>确保指定距离的概念是有意义的</li>
<li>仔细选择群集数量</li>
</ul>
</li>
<li>识别出集群后，以描述性方式标记集群通常很有用</li>
</ol>
<h3 id="6-高中生聚类分析"><a href="#6-高中生聚类分析" class="headerlink" title="6. 高中生聚类分析"></a>6. 高中生聚类分析</h3><p><img src="/2018/10/10/聚类/1539182847475.png" alt="1539182847475"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/聚类/">聚类</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/10/10/聚类/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/09/HMAC算法/"><span>HMAC算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/09/HMAC算法/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-09T13:25:29.000Z">
          2018-10-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="HMAC-消息摘要算法"><a href="#HMAC-消息摘要算法" class="headerlink" title="HMAC - 消息摘要算法"></a>HMAC - 消息摘要算法</h2><h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><p>在密码学中，（消息认证码）Message Authentication Code 是用来认证消息的比较短的信息。<br>换言之，<strong>MAC用来保证消息的数据完整性和消息的数据源认证</strong> </p>
<p>MAC由消息本身和一个密钥经过一系列计算产生，用于生成MAC的算法，称为MAC算法。</p>
<p>MAC算法应能满足如下几个条件:</p>
<ol>
<li><p>在仅有消息本身没有密钥的情况下，无法得到该消息的 MAC</p>
</li>
<li><p>同一个消息在使用不同密钥的情况下，生成的 MAC 应当无关联</p>
</li>
<li><p>在已有一系列消息以及其 MAC 时，给定一个新的消息，无法得到该消息的 MAC</p>
</li>
</ol>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/08/MAC.svg/661px-MAC.svg.png" alt="维基百科"></p>
<p>上图为维基百科上 MAC 算法使用示例。</p>
<h3 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h3><p>HMAC（Hash-based Message Authentication Code，哈希消息认证码）利用<code>哈希算法</code>，<strong>以一个密钥和一个消息为输入，生成一个消息摘要作为输出</strong> </p>
<p>HMAC 是 IP 安全里必须实现的 MAC 方案，并且其他 Internet 协议中（如SSL）也使用了 HMAC。</p>
<p><strong>HMAC的设计目标</strong> </p>
<ol>
<li>可以直接使用现成的 Hash 函数</li>
<li>很容易用更好地 Hash 函数替代原来嵌入的 Hash 函数</li>
<li>能够保持 Hash 函数的原有性能，不能过分降低其性能</li>
<li>对密钥的使用和处理应较简单</li>
<li>如果已知嵌入的 Hash 函数的强度，完全可以知道认证机制抗密码分析的强度</li>
</ol>
<p>正是 HMAC 的这些设计目标保证了HMAC的灵活性、可用性和扩展性，从而得到了广泛的支持。</p>
<p>定义 HMAC 需要一个加密用散列函数（表示为 H，可以是 MD5 或者 SHA-1）和一个密钥 K。我们用 B 来表示数据块的字节数。（以上所提到的散列函数的分割数据块字长 B=64），用 L 来表示散列函数的输出数据字节数（MD5  中 L=16, SHA-1 中 L=20）。鉴别密钥的长度可以是小于等于数据块字长的任何正整数值。应用程序中使用的密钥长度若是比 B 大，则首先用使用散列函数 H 作用于它，然后用 H 输出的L长度字符串作为在 HMAC 中实际使用的密钥。</p>
<p>一般情况下，推荐的最小密钥 K 长度是 L 个字节。</p>
<h4 id="算法表示"><a href="#算法表示" class="headerlink" title="算法表示"></a>算法表示</h4><p>算法公式 ：</p>
<p><strong>HMAC( K, M ) = H( K⊕Opad | H( K⊕Ipad | M) ) </strong>   </p>
<p>H 代表所采用的HASH算法(如SHA-256)</p>
<p>K 代表认证密钥</p>
<p>Ko 代表HASH算法的密文</p>
<p>M 代表一个消息输入</p>
<p>B 代表H中所处理的块大小，这个大小是处理块大小，而不是输出 hash 的大小</p>
<p>如，SHA-1 和 SHA-256 B = 64</p>
<p>SHA-384 和 SHA-512 B = 128</p>
<p>L 表示 hash 的大小</p>
<p>Opad 用 0x5c 重复 B 次</p>
<p>Ipad 用 0x36 重复 B 次</p>
<p>Apad 用 0x878FE1F3 重复 (L/4) 次</p>
<h4 id="HMAC运算步骤"><a href="#HMAC运算步骤" class="headerlink" title="HMAC运算步骤"></a>HMAC运算步骤</h4><p>First-Hash = H( Ko XOR Ipad || (data to auth) )</p>
<p>Second-Hash = H( Ko XOR Opad || First-Hash)</p>
<ol>
<li>在密钥 K 后面添加0来创建一个字长为 B 的字符串。(例如，如果 K 的字长是20字节，B=64 字节，则K后会加入44个零字节0x00)</li>
<li>将上一步生成的 B 字长的字符串与 ipad 做异或运算</li>
<li>将数据流 text 填充至第二步的结果字符串中</li>
<li>用 H 作用于第三步生成的数据流</li>
<li>将第一步生成的 B 字长字符串与 opad 做异或运算</li>
<li>再将第四步的结果填充进第五步的结果中</li>
<li>用 H 作用于第六步生成的数据流，输出最终结果</li>
</ol>
<h4 id="HMAC的应用"><a href="#HMAC的应用" class="headerlink" title="HMAC的应用"></a>HMAC的应用</h4><p>HMAC 主要应用在<code>身份验证</code>中，它的使用方法是这样的：</p>
<ol>
<li>客户端发出登录请求（假设是浏览器的GET请求）</li>
<li>服务器返回一个随机值，并在会话中记录这个随机值</li>
<li>客户端将该随机值作为密钥，用户密码进行 HMAC 运算，然后提交给服务器</li>
<li>服务器读取用户数据库中的用户密码和步骤2中发送的随机值做与客户端一样的 HMAC 运算，然后与用户发送的结果比较，如果结果一致则验证用户合法</li>
</ol>
<p>在这个过程中，可能遭到安全攻击的是服务器发送的随机值和用户发送的 HMAC 结果，而对于截获了这两个值的黑客而言这两个值是没有意义的，绝无获取用户密码的可能性。</p>
<p>随机值的引入使 HMAC 只在当前会话中有效，大大增强了安全性和实用性。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://en.wikipedia.org/wiki/Message_authentication_code" target="_blank" rel="noopener">Message authentication code</a> </p>
<p><a href="http://blog.51cto.com/xwandrew/2050973" target="_blank" rel="noopener">MAC与HMAC介绍</a> </p>
<p><a href="https://www.cnblogs.com/block2016/p/5635111.html" target="_blank" rel="noopener">HMAC</a> </p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/安全协议/">安全协议</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/10/09/HMAC算法/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/09/DH-Diffie–Hellman-算法/"><span>DH(Diffie–Hellman)算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/09/DH-Diffie–Hellman-算法/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-09T09:49:24.000Z">
          2018-10-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="DH密钥协商（Diffie–Hellman-key-exchange）算法"><a href="#DH密钥协商（Diffie–Hellman-key-exchange）算法" class="headerlink" title="DH密钥协商（Diffie–Hellman key exchange）算法"></a>DH密钥协商（Diffie–Hellman key exchange）算法</h2><p>DH 是 Diffie-Hellman的首字母缩写，是Whitefield与Martin Hellman在1976年提出了一个的密钥协商协议。其安全性源于在有限域上计算离散对数。该算法可以使两个用户之间安全地交换一个密钥，但不能用于加密或解密信息。</p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p><img src="/2018/10/09/DH-Diffie–Hellman-算法/427px-Diffie-Hellman_Key_Exchange.svg.png" alt="维基百科示例"></p>
<ol>
<li>Alice和Bob首先约定好公开的一种颜色，比如黄色</li>
<li>Alice和Bob各自挑选出一种私密的颜色，比如橙色和青色</li>
<li>Alice和Bob各自将两种颜色混合起来</li>
<li>双方交换混合后的颜色</li>
<li>Alice和Bob各自将自己的私密颜色再次混入得到的颜色中</li>
<li>现在Alice和Bob得到了一种相同的颜色，这种颜色是由一份黄色、一份橙色、一份青色混合而来，但外界无法得知</li>
</ol>
<p>颜色混合是一种“不可逆”的操作，当双方交换颜色时，尽管我们知道他们交换的颜色都是由一份黄色和另一份其他颜色混合得到的，但我们还是无法或者很难得到他们的私密颜色。而DH秘钥交换的原理非常相似，也是利用了数学上的一个<code>“不可逆”</code>的运算，就是<code>离散对数</code></p>
<p><code>乘方得逆运算称为对数运算</code>，比如已知</p>
<p><strong>7^x = 49</strong> </p>
<p>那么可知</p>
<p><strong>x = log7 49 = 2</strong></p>
<p>对数运算非常容易，即使在数字很大的时候是，但如果是下面的情况</p>
<p><strong>7^x mod 13 = 8</strong> </p>
<p>求X的过程称为“离散对数”，就不那么容易了，在数字很大时几乎是一个不可能的运算，而DH秘钥交换就是利用了这种离散对数计算非常困难的特性来设计的。</p>
<p>公式里的mod是取模运算，取模运算有几条基本的定律如下</p>
<p><strong>(a+b) mod P = (a mod P + b mod P) mod P </strong></p>
<p><strong>(a<em>b) mod P = (a mod P </em> b mod P) mod P </strong></p>
<p><strong>(a^b) mod P = ((a mod P)^b) mod P</strong> </p>
<p>根据上面的公式，可以推导出一个非常重要的公式</p>
<p><strong>(G^(a*b)) mod P = (G^a mod P)^b mod P = (G^b mod P)^a mod P</strong> </p>
<p>根据这个公式，我们可以向上面交换颜色那样设计出一个秘密交换数字的流程出来</p>
<ol>
<li><p>A和B首先约定两个公开的质数 p 和 g</p>
</li>
<li><p>A和B各自随机产生两个数 a, b，作为自己的私钥</p>
</li>
<li><p>各自计算出自己的公钥 A, B</p>
<p><strong>A = g^a mod p</strong> </p>
<p><strong>B = g^b mod p</strong> </p>
</li>
<li><p>交换公钥 A, B</p>
</li>
<li><p>计算出加密用的密钥S</p>
<p><strong>Sa=B^a mod p=(g^b mod p)^a mod p=g^(a*b) mod p</strong> </p>
<p><strong>Sb=A^b mod p=(g^a mod p)^b mod p=g^(a*b) mod p</strong> </p>
</li>
</ol>
<p>最终两个人得到的秘密数字都是 g^(ab) mod p，而窃听者仅从p, g, A, B四个公开信息，是无法得到这个秘密数字的</p>
<p>举个例子，假如 p=23，g=5，Alice选取的秘密数字 a=6，那么 A=5^6 mod 23=8，Bob选取的秘密数字是 b=15，那么 B=5^15 mod 23=19，交换A和B后，Alice计算出的密钥 Sa=19^6 mod 23=2，Bob计算出的密钥 Sb=8^15 mod 23=2<br>当然，实际运算中不可能取这么小的数值，比如如果需要128bit长度的密钥，那么p值需要是128bit长度的质数，由于有模运算，所获得的密钥不会大于p，所以p值可以是128bit数字中最大的一个质数，g可以随便设置一个小的质数即可。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>如果注意的是，为了防止应用优化算法计算上述问题，<strong>质数p不是随便选择</strong>的，需要符合一定的条件。</p>
<p><strong>随机数a、b的生成算法也必需注意</strong>，应使结果尽可能随机，不能出现可预测的规律，否则会使破解变的容易。</p>
<p>通过上述计算过程也可以看出DH算法不仅可以应用在2方通信的情况，如果<strong>多方通信</strong>，也可以使用该算法。</p>
<p>DH密钥交换算法<strong>无法验证对方身份</strong>，所以DH密钥交换算法<strong>不能抵御中间人攻击</strong> </p>
<p><strong>DH算法中间人攻击原理：</strong> </p>
<p>从其原理之中可以看出，a，b 值并没有什么关系，<code>a，b不能证明通信双方Alice与Bob的身份</code>，这使得<code>重放攻击</code>可以轻易产生。</p>
<p>假设一个攻击者 Tom，当 Alice 向 Bob 发送 g, p, A 时，Tom 截获了信息，并（假装自己是 Bob）向 Alice 发送了 T=g^t mod p，其中 t 是 Tom 的私钥。同时 Tom（假装自己是 Alice）向 Bob 发送 g，p，T=g^t mod p，这样 Bob 以为这是 Alice 发过来的，就向 T 发送了 B=g^b  mod p。</p>
<p>在 Alice 与 Tom 之间，创建的密钥就是 Sta=g^at mod p，两方密钥相同。</p>
<p>在 Tom 与 Bob 之间，创建的密钥就是 Stb=g^tb mod p，两方密钥相同。</p>
<p>这样，密钥创建完成，Alice 与 Bob 都认为自己与对方分享了只有他们两人所知的密钥，实际上并不是。当 Alice 想要发信息给 Bob 时，Alice 就会将信息用 Sta=g^at mod p 加密后发出，消息 Bob 无法解密，但会被 Tom 收到并解密，这样 Tom 可以或者扣留信息，或者篡改信息用 Stb=g^tb mod p 加密后发给 Bob，这样 Bob 会收到他认为是 Alice 发来的，其实是 Tom 发过来的经过篡改的信息。这样重放攻击就产生了。</p>
<p><strong>解决：</strong> </p>
<p>可以采用数据签名技术解决中DH密钥交换过程中可能存在的中间人攻击</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>链接：</p>
<p><a href="https://www.jianshu.com/p/18aed34904c9" target="_blank" rel="noopener">DH密钥交换（Diffie–Hellman key exchange）算法笔记</a> </p>
<p><a href="https://thecodeway.com/blog/?p=964" target="_blank" rel="noopener">一个简单的DH密钥协商算法的实现</a> </p>
<p><a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank" rel="noopener">Diffie–Hellman key exchange</a> </p>
<p><a href="https://blog.csdn.net/wxlqaz1995/article/details/52693407?locationNum=13" target="_blank" rel="noopener">关于Diffie-Hellman密钥协商机制以及中间人攻击</a> </p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/安全协议/">安全协议</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/10/09/DH-Diffie–Hellman-算法/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/10/09/快速幂算法/"><span>快速幂算法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/09/快速幂算法/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-09T02:56:15.000Z">
          2018-10-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="快速幂算法"><a href="#快速幂算法" class="headerlink" title="快速幂算法"></a>快速幂算法</h2><h4 id="平方乘算法"><a href="#平方乘算法" class="headerlink" title="平方乘算法"></a>平方乘算法</h4><p>RSA 加解密中存在指数运算 X^a。通常解密运算中的指数非常大，a 的二进制位数通常会大于等于1024 bit，即可能 a &gt;= 2^1024。如果用一般方法直接计算 X^a 的值， 即 X*X*X……需要的运算量非常大，很容易溢出。</p>
<p>定义：MUL 为乘法运算即乘以 X，sq 为平方运算</p>
<p>考虑一个例子计算 X^8，则最简单的方法需要8次乘法运算<br><img src="/2018/10/09/快速幂算法/28852942_1481110425d8oz.png" alt="img"></p>
<p>而更快捷的方法只需要3次平方运算<br><img src="/2018/10/09/快速幂算法/28852942_1481029833JAX4.png" alt="img"><br>在看一个更一般的例子，计算 X^24，最简单的方法就是计算24次乘法。</p>
<p>更有效的方法如下：即一次平方操作，一次乘法操作(乘以 X)，之后再三次平放操作。 即5次操作即可得到结果<br><img src="/2018/10/09/快速幂算法/28852942_1481030092Hl1m.png" alt="img"><br>也就是说对于指数运算两种基本操作就可以得到结果：对当前结果平方，当前结果与 X 相乘。问题是如何确定平方与乘法的执行顺序, 平方-乘算法就可以解决这个问题。</p>
<p><strong>大致描述为： 对 X^a  将指数 a 表示为2进制形式，高bit在左，然后从左至右扫描对应的 bit 位。除了最左边的 bit（MSB）以外，在扫描之后每个 bit 位时对当前结果平方，如果该bit位为1，则需多进行一次乘法操作</strong></p>
<p>以计算 X^24 为例：</p>
<blockquote>
<p>黑体表示二进制形式</p>
</blockquote>
<p>X^24 将指数表示为二进制形式 X^<strong>11000</strong> 表示为 X^<strong>b1b2b3b4b5</strong></p>
<p>开始扫描指数的每个Bit: </p>
<ol>
<li>初始值 X = X^<strong>1</strong>;                 初始化设置，<strong>b1</strong> = 1，扫描第一个bit时不需要做其他操作</li>
<li>X^2 = X^<strong>11</strong>                      <strong>b2</strong>=1，先平方 X^2*X = X^3 = X<strong>11</strong> ，再乘以 X</li>
<li>(X^3)^2 = X^6 = X^<strong>110</strong>          <strong>b3</strong>= 0，只需要一次平方</li>
<li>(X^6)^2 = X^12 = X^<strong>1100</strong>         <strong>b4</strong> = 0，只需要一次平方</li>
<li>(X^12)^2 = X^24 = X^<strong>11000</strong>     <strong>b5</strong> = 0,只需一次平方</li>
</ol>
<p>通过观察运算过程中指数的二进制表示的变化能更好的理解算法，一次平方操作会让指数向左移一位，并在最右边添加0，<br>而与 X 相乘的操作即在指数的最右边位置上填上 1 </p>
<h4 id="快速幂算法-1"><a href="#快速幂算法-1" class="headerlink" title="快速幂算法"></a>快速幂算法</h4><p><strong>所谓的快速幂，实际上是快速幂取模的缩写，简单的说，就是快速的求一个幂式的模(余)。在程序设计过程中，经常要去求一些大数对于某个数的余数，为了得到更快、计算范围更大的算法，产生了快速幂取模算法。</strong></p>
<p>快速幂实现基于引理：积的取余等于取余的积的取余，即：</p>
<p><strong>(a * b) mod n=(a mod n * b mod n) mod n</strong> </p>
<p>示例：4^24 mod 102 = 52</p>
<p>24 = <strong>11000</strong></p>
<p>4^24 mod 102     = ( ( ( ( (4^1)*(4^1)^2 ) ^2) ^2) ^2) mod 102</p>
<p>​                = ( ( ( 64 ^2) ^2) ^2) mod 102</p>
<p>​                = ( ( ( 64 ^2) ^2) mod 102) ^2 mod 102</p>
<p>​                = ( ( ( 64 ^2) mod 102)^2 mod 102) ^2 mod 102</p>
<p>​                = ( ( 256 mod 102)^2 mod 102) ^2 mod 102</p>
<p>​                = ( 52^2 mod 102) ^2 mod 102</p>
<p>​                =  ( 52^2) mod 102</p>
<p>​                = 52</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/密码学/">密码学</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/10/09/快速幂算法/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/30/TCP-IP-详解（一）-网络基础知识/"><span>TCP/IP 详解（一） 网络基础知识</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/30/TCP-IP-详解（一）-网络基础知识/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-30T01:25:20.000Z">
          2018-09-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="TCP-IP-详解（一）-网络基础知识"><a href="#TCP-IP-详解（一）-网络基础知识" class="headerlink" title="TCP/IP 详解（一） 网络基础知识"></a>TCP/IP 详解（一） 网络基础知识</h2><h3 id="1-计算机网络发展"><a href="#1-计算机网络发展" class="headerlink" title="1. 计算机网络发展"></a>1. 计算机网络发展</h3><p>计算机发展是从<code>独立模式</code>到<code>网络互连模式</code>的。</p>
<p>​    独立模式：单机模式，指计算机未连接网络，各自独立使用的方式</p>
<p>​    网络互联模式：将计算机连在一起，形成一个计算机网络，信息共享、传递消息等</p>
<p>计算机网络按规模划分（定义比较宽泛）</p>
<p>​    WAN（Wide Area Network，广域网）：覆盖多个远距离区域的远程网络</p>
<p>​    MAN（Metropolitan Area Network，城域网）：连接一个城市的网络</p>
<p>​    LAN（Local Area Network，局域网）：一幢楼、一个学校等</p>
<p>计算机网络发展的7个阶段</p>
<ol>
<li><p>批处理（Batch Processing）：20世纪50年代，事先将用户程序及数据装入卡带或磁带，并由计算机按照一定顺序读取，使用户所执行的这些程序和数据能够一并批量得到处理的方式（脱机、多道、成批处理）</p>
</li>
<li><p>分时系统（Time Sharing System，TSS）：20世纪60年代，多个终端与同一计算机连接，允许多个用户同时使用一台计算机。系统采用时间片轮转的办法在客观效果上用户批次感觉不到对方也在使用这台计算机，<code>好像</code>只有自己独占这台计算机一样（独占性、星型、交互性、多路性、及时性），计算机与终端进行连接（计算机与计算机之间并没有互相连接）</p>
<blockquote>
<p>这里的<code>终端</code>由输入输出设备（显示器、键鼠等）组成</p>
</blockquote>
</li>
<li><p>计算机之间的通信：20世纪70年代，计算机与计算机之间通信，传输数据，提高了计算机的可用性</p>
</li>
<li><p>计算机网络的产生：20实际80年代，能够连接多种计算机（异构）的网络产生，窗口系统发明并与网络结合  -&gt;  网上冲浪</p>
<blockquote>
<p>窗口系统的发明使用户可以同时执行多个程序，还可以在这些程序之间自由的切换作业</p>
</blockquote>
</li>
<li><p>互联网的普及：20实际90年代，一人一机（成本不菲），推出“瘦身”、“多供应商连接”。E-mail，WWW等信息传播方式迎来了前所未有的发展</p>
<blockquote>
<p>瘦身：用“轻量型”个人电脑或UNIX工作站取代大型主机，降低网络架构成本</p>
<p>多供应商连接：将各种软硬件供应商的产品组合起来搭建网络，降低网络环境成本（异构型计算机之间的连接）</p>
</blockquote>
</li>
<li><p>以互联网为中心：2000年，从电话网到IP网</p>
</li>
<li><p>建立连接 -&gt; 安全建立连接（完善）：2010年，随着互联网的普及，网络安全问题愈发突出，建立连接发展为安全建立连接</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>年代</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>20世纪50年代</td>
<td>批处理时代</td>
</tr>
<tr>
<td>20世纪60年代</td>
<td>分时系统时代</td>
</tr>
<tr>
<td>20世纪70年代</td>
<td>计算机通信时代</td>
</tr>
<tr>
<td>20世纪80年代</td>
<td>计算机网络时代</td>
</tr>
<tr>
<td>20世纪90年代</td>
<td>互联网普及时代</td>
</tr>
<tr>
<td>2000年</td>
<td>以互联网为中心时代</td>
</tr>
<tr>
<td>2010年</td>
<td>无论何时何地一切皆TCP/IP的网络时代</td>
</tr>
</tbody>
</table>
<h3 id="2-网络通信协议"><a href="#2-网络通信协议" class="headerlink" title="2. 网络通信协议"></a>2. 网络通信协议</h3><p><code>TCP/IP协议是通信协议的统称</code></p>
<p>计算机网络最初的目的是连接一个个独立的计算机，使他们组成一个更强有力的计算环境（提高生产力），现代计算的首要目的之一是<code>连接人与人</code>，事置身于世界各地的人门可以通过网络建立联系、相互沟通、交流思想</p>
<p>协议就是计算机与计算机之间通过网络实现通信通信时事先达成的一种“约定”。不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间只要遵循相同的协议就能够实现通信。相当于语言</p>
<p>协议可以分为很多种，每一种协议都明确地界定了它的行为规范。两台计算机之间必须能够支持相同的协议，并 遵循相同协议进行处理，这样才能实现相互通信。</p>
<blockquote>
<p>CPU: Central Processing Unit, 中央处理器。每个程序实际上是由它调度执行的，CPU的性能很大程度上也决定着一台计算机的处理性能。</p>
<p>一个CPU通常在同一时间只能运行一个程序。为了让多个程序同时运行，操作系统采用CPU时间片轮转机制，在多个程序之间进行切换，合理调度</p>
</blockquote>
<p>协议如同人与人之间的交流方式</p>
<p><img src="/2018/09/30/TCP-IP-详解（一）-网络基础知识/1541121891482.png" alt="1541121891482"></p>
<h4 id="分组交换协议"><a href="#分组交换协议" class="headerlink" title="分组交换协议"></a>分组交换协议</h4><p>分组交换是指将大数据分割成一个个叫做包（Packet）的较小单位进行传输的方法</p>
<p><img src="/2018/09/30/TCP-IP-详解（一）-网络基础知识/1541122634140.png" alt="1541122634140"></p>
<p>计算机通信会在每一个分组中附加上源主机地址和目标主机地址送给通信线路，这些发送端地址、接收端地址以及分组序号写入的部分称为<code>报文首部</code>。接收端根据分组序号将每个分组按照序号重新分配为原始数据</p>
<p>通信协议中，通常会规定报文首部应该写入哪些信息、应该如何处理这些信息。分组发送方和接收方有必要对报文首部和内容保持一致的定义和解释</p>
<h4 id="协议的标准化"><a href="#协议的标准化" class="headerlink" title="协议的标准化"></a>协议的标准化</h4><p>ISO（International Organization for Standards，国际标准化组织）制定了一个国际标准OSI（Open Systems Interconnection，开放式通信系统互联参考模型），对通信协议进行标准化（OSI协议没有得到普及，OSI参考模型经常被应用于网络协议的指定中）</p>
<blockquote>
<p>OSI协议是为了让异构的计算机之间能够相互通信的、由ISO和ITU- T推进其标准化的一种网络体系结构</p>
</blockquote>
<p>TCP/IP协议由IETF（Internet Engineering Task Force）标准化</p>
<h4 id="协议的分层与OSI参考模型"><a href="#协议的分层与OSI参考模型" class="headerlink" title="协议的分层与OSI参考模型"></a>协议的分层与OSI参考模型</h4><p><strong>协议的分层</strong></p>
<p>OSI参考模型将通信协议必要的功能分为了7层。在这一模型中，每个分层都接收由它下一层所提供的特定服务。上下层之间进行交互时所遵循的约定叫做<code>接口</code>。同一层之间的交互所遵循的约定叫做<code>协议</code>。</p>
<p>分层的优势：分层可以将每个分层独立使用，即使系统中某些分层发生变化，也不会波及整个系统。因此，可以构造一个扩展性和灵活性都较强的系统。此外，通过分层能够细分通信功能，更易于单独实现每个分层的协议，并界定各个分层的具体责任和义务。</p>
<p>分层的劣势：过分模块化、使处理变得更加沉重以及每个模块都不得不实现相似的处理逻辑等问题。</p>
<p><img src="/2018/09/30/TCP-IP-详解（一）-网络基础知识/1541124413346.png" alt="1541124413346"></p>
<p><strong>OSI参考模型</strong></p>
<p><img src="/2018/09/30/TCP-IP-详解（一）-网络基础知识/1541124464749.png" alt="OSI参考模型与协议的含义"></p>
<p>OSI参考模型中各个分层的作用</p>
<p><img src="/2018/09/30/TCP-IP-详解（一）-网络基础知识/1541125675833.png" alt="1541125675833"></p>
<p>应用层：为应用程序提供服务并规定应用程序中通信相关细节。包括文件传输、电子邮件、远程登录（虚拟终端）等协议。</p>
<p>表示层：主要负责数据格式的转换。具体来说，就是将设备固有的数据格式转换为网络标准传输格式。不同设备对同一比特流解释的结果可能会不同。因此，使它们保持一致是这一层的主要作用。</p>
<p>会话层：负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理</p>
<p>传输层：起着可靠传输的作用。只在通信双方节点上进行处理，而无需在路由器上处理</p>
<p>网络层：将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择</p>
<p>数据链路层：负责物理层面上互连的、节点之间的通信传输；将0、1序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）</p>
<p>物理层：负责0、1比特流（0、1序列）与电压的高低、光的闪灭之间的转换</p>
<p>例子：A向B发送电子邮件</p>
<ol>
<li>7层通信</li>
</ol>
<p><img src="/2018/09/30/TCP-IP-详解（一）-网络基础知识/1541127377627.png" alt="1541127377627"></p>
<ol start="2">
<li><p>会话层以上的处理</p>
<p>应用层：A新建邮件，指定收件人为B，并输入内容，点击发送邮件之后就会进入应用层协议处理。该协议会在所要处理的数据前端添加一个首部（标签）信息。B收到邮件后，分析数据首部与数据正文</p>
<p>表示层：将数据从某个计算机特定的数据格式转换为网络通用的标准数据格式再发出去。接收端接收后将数据恢复为该计算机特定的数据格式，然后再处理（例如转为 UTF-8）</p>
<p>会话层：决定采用何种连接方式是会话层的主要责任</p>
</li>
<li><p>传输层一下的处理</p>
<p>传输层：进行建立连接或断开连接的处理（会话层决定建立连接 和断开连接的时机，传输层进行实际的建立连接和断开连接），在两个主机间创建逻辑上的通信连接是传输层的主要作用，还会负责重发。保证数据传输的可靠性</p>
<p>网络层：将数据传输给对端（根据目的地址，整体）</p>
<p>数据链路层、物理层：将数据传输给对端（根据MAC地址，一个分段）</p>
</li>
</ol>
<h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>大致分为面向有连接与无连接两种类型<br>面向无连接：以太网、IP、UDP协议等<br>面向有链接：ATM、帧中继、TCP协议等</p>
<p>面向无连接：无需确认对端是否存在，发送端可随时发送数据</p>
<p><img src="/2018/09/30/TCP-IP-详解（一）-网络基础知识/1544056962683.png" alt="1544056962683"></p>
<p>面向有连接：在通信传输之前，先打开一个连接，连接被关闭是无法传输数据</p>
<p><img src="/2018/09/30/TCP-IP-详解（一）-网络基础知识/1544057079751.png" alt="1544057079751"></p>
<p>面向有连接型中，在发送数据之前，需要在收发主机之间连接一条通信线路（在不同的分层协议中，连接的具体含义可能有所不同。在数据链路层中的连接，就是指物理的、通信线路的连接。而传输层则负责创建与管理逻辑上的连接。），</p>
<p>好比电话，输入对方号码拨出之后，只有对端拿起电话才能真正通话，通话结束之后将电话机扣上就如同切断电源。</p>
<p>面向无连接型不要求建立和断开连接。发送端可于任何时候自由发送数据，但接收端不知道自己会在什么时候接收数据，所以，接收端需要常常确认是否收到了数据。类似于寄包裹。即使不知道对端是否存在或能否接收数据，发送端也能将数据发送出去。</p>
<h3 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h3><p>目前，网络通信方式大致为两种——电路交换和分组交换。电路交换主要用于过去的电话网。TCP/IP技术采用了分组交换技术。</p>
<p>电路交换：交换机负责数据的中转处理。计算机之间发送数据时，需要通过交换机与目标主机建立通信电路。我们将连接电路称为建立连接。建立好连接后，用户可以一直使用这条电路，知道该连接被断开（独占）。当有一条电路连接了多台计算机时，某一台计算机在收发信息时会独占整个电路，其他计算机只能等待这台计算机处理结束以后才有机会使用这条电路收发数据。并且在此过程中，谁也无法预测某一台计算机的数据传输从何时开始又在何时结束。如果并发用户数超过交换机之间的通信线路数，就意味着通信根本无法实现。</p>
<p>分组交换：让连接到通信电路的计算机将所要发送的数据分成多个数据包，按照一定的顺序排列之后分别发送。这就是分组交换。有了分组交换，数据被细分后，所有的计算机就可以一齐收发数据，这样也就提高了通信线路的利用率。由于在分组的过程中，已经在每个分组的首部写入了发送端和接收端的地址，所以即使同一条线路同时为多 个用户提供服务，也可以明确区分每个分组数据发往的目的地，以及它是与哪台计算机进行的通信。</p>
<p><img src="/2018/09/30/TCP-IP-详解（一）-网络基础知识/1544059657894.png" alt="1544059657894"></p>
<p>在分组交换 中，由分组交换机（路由器）连接通信线路。分组交换的大致处理过程是：发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，缓存到自己的缓冲区，然后再转发给目标 计算机。因此，分组交换也有另一个名称：蓄积交换。</p>
<p>路由器接收到数据以后会按照顺序缓存到相应的队列当中，再以<code>先进先出</code>的顺序将它们逐一发送出去（有时，也会优先发送目标地址比较特殊的数据）。</p>
<p>在分组交换中，计算机与路由器之间以及路由器与路由器之间通常只有一条通信线路。因此，这条线路其实是一条 共享线路。在电路交换中，计算机之间的传输速度不变。然而在分组交换中，通信线路的速度可能会有所不同。根据网络拥堵的情况，数据达到目标地址的时间有长有短。另外，路由器的缓存饱和或溢出时，甚至可能会发生分组数据丢失、无法发送到对端的情况。</p>
<h3 id="根据接收端数量分类"><a href="#根据接收端数量分类" class="headerlink" title="根据接收端数量分类"></a>根据接收端数量分类</h3><p>单播（Unicast）：1对1通信，固定电话</p>
<p>广播（Broadcast）：1对多，电视播放。广播范围-广播域</p>
<p>多播（Multicast）：1对多，但是要限制接收端，电话会议（需要限定成员）</p>
<p>任播（Anycast）：1对1，在一堆客户端中选取最适合的一个进行通信，DNS根域名解析服务器。</p>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>每一层协议使用的地址都不相同。</p>
<p>TCP/IP通信中使用MAC地址、IP地址、端口号等信息作为地址标识。在应用层可以将电子邮件地址作为网络通信地址</p>
<p>地址应具有唯一性：在同一通信网络中不允许有两个相同地址的通信主体存在</p>
<p>地址具有层次性：地址总数越来越多的时候，为了高效快速的找出通信地址的目标地址将成为一个重要的问题。IP地址具有层次性，MAC地址不具有。</p>
<p>IP地址的分层：IP地址由网络号和主机号两部分组成。即使通信主体的IP地址不同，若主机号不同、网络号相同，说明他们处于同一网段。通常，同处于一个网段的主机也都属于同一个部门或集团组织，另一方面， 网络号相同的主机在组织结构、提供商类型和地域分布上都比较集中，也为 IP 寻址带来了极大的方便（聚合性）</p>
<p>网络传输中，每个节点会根据分组数据的地址信息，来判断该报文应该由哪个网卡发送出去。为此，各个地址会参考一个发出接口列表。在这一点上MAC寻址与IP寻址是一样的。只不过MAC寻址中所参考的这张表叫做<code>地址转发表</code>，而IP寻址中所参考的叫做<code>路由控制表</code>，目前地址转发表和路由控制表并不需要在网络中的各个节点上手动设置， 而是由这些节点自动生成的。</p>
<p>地址转发表根据自学自动 成。 路由控制表则根据路由协议自动生成。</p>
<p>MAC地址转发表中所记录的是实际的MAC地址本身，而路由表中记录的IP地址则是集中了之后的网络号（确切的说，是网络号与子网掩码）。</p>
<p><img src="/2018/09/30/TCP-IP-详解（一）-网络基础知识/1544062824072.png" alt="1544062824072"></p>
<h3 id="网络的构成要素"><a href="#网络的构成要素" class="headerlink" title="网络的构成要素"></a>网络的构成要素</h3><p>介绍连接计算机与计算机的硬件设备。</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>网卡</td>
<td>使计算机联网的设备（Network Interface）</td>
</tr>
<tr>
<td>中继器（Repeater）</td>
<td>从物理层上延长网络的设备</td>
</tr>
<tr>
<td>网桥（Bridge）/2层交换机</td>
<td>从数据链路层上延长网络的设备</td>
</tr>
<tr>
<td>路由器（Router）/3层交换机</td>
<td>从网络层转发分组数据的设备</td>
</tr>
<tr>
<td>4-7层交换机</td>
<td>处理传输层以上各层网络传输的设备</td>
</tr>
<tr>
<td>网关（Gateway）</td>
<td>转换协议的设备</td>
</tr>
</tbody>
</table>
<p>网卡（网络接口卡，NIC）</p>
<p>中继器（Repeater）：中继器（Repeater）是在OSI模型的第1层——物理层面上延长网络的设备。由电缆传过来的电信号或光信号经由中继器的波形调整和放大再传给另一个电缆。</p>
<p>一般情况下，中继器的两端连接的是相同的通信媒介，但有的中继器也可以完成不同媒介之间的转接工作，但是这种中继器只能单纯的负责信号在0、1比特流之间的转换，并不负责判断数据是否有错误</p>
<p>有些中继器可以提供多个端口服务。这种中继器被称作中继集线器或集线器。因此，集线器（中继集线器也可以简称为集线器或Hub）也可以看作是多口中继器</p>
<p>网桥：网桥是在OSI模型的第2层——数据链路层面上连接两个网络的设备。它能够识别数据链路层中的数据帧（与分组数据意思大致相同，但是在数据链路层中通常习惯称为帧），并将这些数据帧临时存储于内存，再重新生成信号作为一个全新的帧转发给相连的另一个网段</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/TCP-IP详解/">TCP/IP详解</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/09/30/TCP-IP-详解（一）-网络基础知识/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/09/27/Hello-World/"><span>Hello World</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/09/27/Hello-World/" rel="bookmark">
        <time class="entry-date published" datetime="2018-09-27T13:30:31.000Z">
          2018-09-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="Test-code"><a href="#Test-code" class="headerlink" title="Test code"></a>Test code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/test/">test</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/09/27/Hello-World/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 HaooJie
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-126549317-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>